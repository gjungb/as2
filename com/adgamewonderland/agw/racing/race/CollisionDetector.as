/* 
 * Generated by ASDT 
*/ 

/*
klasse:			CollisionDetector
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		14.06.2005
zuletzt bearbeitet:	28.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

//import com.adgamewonderland.agw.physics.*;

//import com.adgamewonderland.agw.racing.race.*;

//import com.adgamewonderland.agw.racing.track.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.race.CollisionDetector {
	
	private static var ATTENUATION_OFFSET:Number = 2;
	
	private var myVehicles:Array;
	
	public function CollisionDetector()
	{
		// fahrzeuge auf der strecke
		myVehicles = new Array();
	}
	
	public function set vehicles(arr:Array ):Void
	{
		// fahrzeuge auf der strecke
		myVehicles = arr;
	}
	
	public function get vehicles():Array
	{
		// fahrzeuge auf der strecke
		return myVehicles;
	}
	
	public function handleCollisions():Void
	{	
		// schleife ueber fahrzeuge (vom ersten bis zum vorletzten)
		for (var i:Number = 0; i < vehicles.length - 1; i++) {
			// erstes fahrzeug
			var v0:Vehicle = vehicles[i];
//			if (v0.controller.isVehicleOffRoad()) break;
//			// ueberspringen, wenn user auf streckenteil, das nicht befahren werden darf
//			if (v0.type == Vehicle.TYPE_USER) {
//				if (v0.controller.isVehicleOffRoad()) {
//					continue;
//				}
//			}
			// schleife ueber nachfolgende fahrzeuge
			for (var j:Number = i + 1; j < vehicles.length; j++) {
				// zweites fahrzeug
				var v1:Vehicle = vehicles[j];
				
				// 1. abstand ermitteln (wenn zu weit auseinander, naechstes fahrzeug)
				if (getVehicleVehicleDistance(v0, v1) > v0.movieclip.collisiondistance) continue;
				// 2. anzahl ecken, mit denen die umrandungen der fahrzeuge ueberlappen (wenn 0, naechstes fahrzeug)
				if (getNumPointsVehicleVehicleCollision(v0, v1) == 0) continue;
				
				// zusammenstoss verarbeiten
				handleCollision(v0, v1);
			}
		}
	}
	
//	public function handleCollisions(colliders:Array ):Void
//	{
//		// schleife ueber kollidierende fahrzeuge (vom ersten bis zum vorletzten)
//		for (var i:Number = 0; i < colliders.length - 1; i++) {
//			// erstes fahrzeug
//			var v0:Vehicle = colliders[i];
//			// umrandung erstes fahrzeug
//			var p0:Polygon = v0.movieclip.getEdgeGlobal();
//			// schleife ueber nachfolgende fahrzeuge
//			for (var j:Number = i + 1; j < colliders.length; j++) {
//				// zweites fahrzeug
//				var v1:Vehicle = colliders[j];
//				// umrandung zweites fahrzeug
//				var p1:Polygon = v1.movieclip.getEdgeGlobal();
//				
//				// punkte von v0, die innerhalb von v1 liegen
//				var points0:Array = LinearAlgebra.getInstance().getPointsInPolygon(p1, p0);
//				// verschiebung erstes fahrzeug
//				var offset0:Vector = new Vector(0, 0);
//				// schleife ueber punkte erstes fahrzeug
//				for (var k:String in points0) {
//					// aktueller punkt
//					var point0:Point = points0[k];
//					// vektor in richtung des mittelpunkts der umrandung erstes fahrzeug
//					offset0.addVector(new Vector(p0.center.x - point0.x, p0.center.y - point0.y));
////					trace(k + ": " + point0.x + ", " + point0.y + " # " + p0.center.x + ", " + p0.center.y + " # " + offset0.xdiff + ", " + offset0.ydiff);
//				}
//				// verschiebung erstes fahrzeug daempfen
//				offset0.multiplyBy(v0.velocity.getLength() / Vehicle.VMAX / ATTENUATION_OFFSET); // 1 / ATTENUATION_OFFSET
//				
//				
//				// punkte von v1, die innerhalb von v0 liegen
//				var points1:Array = LinearAlgebra.getInstance().getPointsInPolygon(p0, p1);
//				// verschiebung zweites fahrzeug
//				var offset1:Vector = new Vector(0, 0);
//				// schleife ueber punkte zweites fahrzeug
//				for (var l:String in points1) {
//					// aktueller punkt
//					var point1:Point = points1[l];
//					// vektor in richtung des mittelpunkts der umrandung zweites fahrzeug
//					offset1.addVector(new Vector(p1.center.x - point1.x, p1.center.y - point1.y));
////					trace(k + ": " + point.x + ", " + point.y + " # " + p0.center.x + ", " + p0.center.y + " # " + offset0.xdiff + ", " + offset0.ydiff);
//				}
//				// verschiebung zweites fahrzeug daempfen
//				offset1.multiplyBy(v1.velocity.getLength() / Vehicle.VMAX / ATTENUATION_OFFSET); // 1 / ATTENUATION_OFFSET
//
//				// erstes fahrzeug verschieben
////				v0.position.movePoint(offset0);
////				v0.acceleration.addVector(offset0);
////				v0.acceleration.setAngle(offset0.getAngle());
////				v0.acceleration.setLength(offset0.getLength());
//				// zweites fahrzeug verschieben
////				v1.position.movePoint(offset1);
////				v1.acceleration.addVector(offset1);
//			}
//		}
//		
//	}
	
	private function handleCollision(v0:Vehicle, v1:Vehicle ):Void
	{
		// umrandung erstes fahrzeug
		var p0:Polygon = v0.movieclip.getEdgeGlobal();
		// umrandung zweites fahrzeug
		var p1:Polygon = v1.movieclip.getEdgeGlobal();
				
		// punkte von v0, die innerhalb von v1 liegen
		var points0:Array = LinearAlgebra.getInstance().getPointsInPolygon(p1, p0);
		// verschiebung erstes fahrzeug
		var offset0:Vector = new Vector(0, 0);
		// schleife ueber punkte erstes fahrzeug
		for (var k:String in points0) {
			// aktueller punkt
			var point0:Point = points0[k];
			// vektor in richtung des mittelpunkts der umrandung erstes fahrzeug
			offset0.addVector(new Vector(p0.center.x - point0.x, p0.center.y - point0.y));
		}
		// verschiebung erstes fahrzeug daempfen
		offset0.multiplyBy(1 / ATTENUATION_OFFSET); // v0.velocity.getLength() / Vehicle.VMAX / ATTENUATION_OFFSET
		
		// punkte von v1, die innerhalb von v0 liegen
		var points1:Array = LinearAlgebra.getInstance().getPointsInPolygon(p0, p1);
		// verschiebung zweites fahrzeug
		var offset1:Vector = new Vector(0, 0);
		// schleife ueber punkte zweites fahrzeug
		for (var l:String in points1) {
			// aktueller punkt
			var point1:Point = points1[l];
			// vektor in richtung des mittelpunkts der umrandung zweites fahrzeug
			offset1.addVector(new Vector(p1.center.x - point1.x, p1.center.y - point1.y));
		}
		// verschiebung zweites fahrzeug daempfen
		offset1.multiplyBy(1 / ATTENUATION_OFFSET); // v1.velocity.getLength() / Vehicle.VMAX / ATTENUATION_OFFSET
		
		// erstes fahrzeug verschieben
		v0.position.movePoint(offset0);
		// zweites fahrzeug verschieben
		v1.position.movePoint(offset1);
		
		// sound
		if (v0.type == Vehicle.TYPE_USER || v1.type == Vehicle.TYPE_USER) {
			var snd:Sound = new Sound(v0.movieclip.shadow_mc);
			snd.attachSound("bounce");
			snd.start();
		}
	}
	
	private function getVehicleVehicleDistance(v0:Vehicle, v1:Vehicle ):Number
	{
		// linearer abstand zwischen den fahrzeugen
		return (LinearAlgebra.getInstance().getPointPointDistance(v0.position, v1.position));
	}
	
	private function getNumPointsVehicleVehicleCollision(v0:Vehicle, v1:Vehicle ):Number
	{
		// anzahl der ecken, mit denen die umrandungen der fahrzeuge ueberlappen
		var numpoints:Number = 0;
		// umrandung erstes fahrzeug
		var p0:Polygon = v0.movieclip.getEdgeGlobal();
		// umrandung zweites fahrzeug
		var p1:Polygon = v1.movieclip.getEdgeGlobal();
		// p0 in p1
		numpoints += LinearAlgebra.getInstance().getNumPolygonInPolygon(p1, p0);
		// p1 in p0
		numpoints += LinearAlgebra.getInstance().getNumPolygonInPolygon(p0, p1);
		// zurueck geben
		return numpoints;
	}
}