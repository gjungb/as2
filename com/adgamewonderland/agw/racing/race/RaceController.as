/* 
 * Generated by ASDT 
*/ 

/*
klasse:			RaceController
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	08.07.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.util.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

import com.adgamewonderland.agw.racing.vehicle.*;

import com.adgamewonderland.blaupunkt.dtmracing.challenge.*;

class com.adgamewonderland.agw.racing.race.RaceController implements Strokable {
		
	private static var _instance : RaceController;
	
	private static var CARS:Number = 3;
	
	public static var LAPS:Number = 3;
	
	private var myTid:Number
	
	private var myCarid:Number;
	
	private var myCaller:Object;
	
	private var myCallback:Function;
	
	private var myTrack:Track;
	
	private var myTrackUI:TrackUI;
	
	private var myDisplay:MovieClip;
	
	private var myMiniTrackUI:MiniTrackUI;
	
	private var myVehicles:Array;
	
	private var myCollisionDetector:CollisionDetector;
	
	private var myStroke:StrokeUI;
	
	private var myTime:Number;
	
	private var myLap:Number;
	
	private var myLapresults:Array;
	
	private var myReplay:ChallengeReplay;
	
	public static function getInstance():RaceController
	{
		if (_instance == null) {
			_instance = new RaceController();
		}
		return _instance;
	}
	
	public function set trackui(mc:TrackUI ):Void
	{
		// movieclip, das die strecke auf der buehne anzeigt
		myTrackUI = mc;
		// movieclip, in dem die informationen fuer den user angezeigt werden
		myDisplay = mc._parent;
	}
	
	public function get trackui():TrackUI
	{
		// movieclip, das die strecke auf der buehne anzeigt
		return myTrackUI;
	}
	
	public function set minitrackui(mc:MiniTrackUI ):Void
	{
		// movieclip, das die ministrecke auf der buehne anzeigt
		myMiniTrackUI = mc;
	}
	
	public function get minitrackui():MiniTrackUI
	{
		// movieclip, das die ministrecke auf der buehne anzeigt
		return myMiniTrackUI;
	}
	
	public function get track():Track
	{
		// aktuelle strecke
		return myTrack;
	}
	
	public function initRace(tid:Number, carid:Number, caller:Object, callback:Function ):Void
	{
		// taktgeber
		myStroke.active = true;
		// id der vom user gewaehlten strecke
		myTid = tid;
		// id des vom user gewaehlten fahrzeugs
		myCarid = carid;
		// caller, der das rennen startet
		myCaller = caller;
		// callback, wenn rennen bereit zum start
		myCallback = callback;
		// strecke laden
		loadTrack(tid);
	}
	
	public function loadTrack(id:Number ):Void
	{
		// laden lassen (ruft onTrackLoaded auf)
		TrackFactory.getInstance().getTrack(id, this, "onTrackLoaded");
	}
	
	public function onTrackLoaded(tobj:Track ):Void
	{
		// aktuelle strecke
		myTrack = tobj;
		// ministrecke anzeigen
		minitrackui.showTrack(track.id);
		// anzeigen
//		trackui.showTrack(tobj);
		// initialisieren der inneren box, ausserhalb der die streckenanzeige nicht bewegt wird
		trackui.initBoxInner(track.width, track.height);
		// streckenabbildung laden lassen (ruft onTrackpicLoaded auf)
		trackui.loadTrackpic(track.id);
	}
	
	public function onTrackpicLoaded():Void
	{
		// startpositionen der fahrzeuge
		var start:Array = track.startpositions;
		// unterschiedliche carids zur besseren unterscheidung
		var usedids:Array = new Array(VehicleUI.NUMCARS);
		// fahrzeug fuer user
		addVehicle(Vehicle.TYPE_USER, new Point(start[0].x, start[0].y), start[0].a, myCarid);
		// id verbraucht
		usedids[myCarid] = true;
		// zufaellige carid fuer computer
		var carid:Number
		// drei computer fahrzeuge
		for (var i:Number = 1; i <= CARS; i++) {
			// carid
			do {
				carid = Math.ceil(Math.random() * VehicleUI.NUMCARS);
			} while (usedids[carid] == true);
			// id verbraucht
			usedids[carid] = true;
			// fahrzeug fuer computer
			addVehicle(Vehicle.TYPE_COMPUTER, new Point(start[i].x, start[i].y), start[i].a, carid);
		}
		// fahrzeuge beim kollsions-detektor anmelden
		myCollisionDetector.vehicles = myVehicles;
		// alle fahrzeuge starten (duerfen noch nicht fahren)
		for (var i:String in myVehicles) {
			// aktuelles fahrzeug
			var vehicle:Vehicle = myVehicles[i];
			// starten
			vehicle.startVehicle();
		}
		// streckenanzeige starten
		trackui.startTrack();
		// callback aufrufen (ruft startLights auf)
		myCallback.apply(myCaller, []);
	}
	
	public function startLights(callback:Function ):Void
	{
		// callback, wenn rennen beendet
		myCallback = callback;
		// ampel starten (ruft startRace auf)
		myDisplay.startlights_mc.startLights(this, startRace);
	}
	
	public function startRace():Void
	{
		// alle fahrzeuge fahren lassen
		for (var i:String in myVehicles) {
			// aktuelles fahrzeug
			var vehicle:Vehicle = myVehicles[i];
			// starten
			vehicle.driving = true;
		}
		// beim taktgeber anmelden
		myStroke.addListener(this);
	}
	
	public function onUpdateStroke():Void
	{
		// zeit zaehlen
//		myTime += myStroke.fpsclip / myStroke.fpsstroke * 100 * 4; // myStroke.fpsstroke / myStroke.fpsclip * 100 / 2;
		myTime += 100 * 4; // myStroke.fpsstroke / myStroke.fpsclip * 100 / 2;
		// anzeigen
		myDisplay.counter_mc.showTime(Math.round(myTime));
		// kollisonen testen
		checkCollisions();
	}
	
	public function onVehicleMove(vobj:Vehicle ):Void
	{
		// je nach typ
		switch (vobj.type) {
			// user
			case (Vehicle.TYPE_USER) :
				// position des fahrzeugs
				var pos:Point = vobj.position;
				// streckenanzeige positionieren
				trackui.centerTo(pos);
				// anzeige, wenn nicht auf strecke
				myDisplay.warning_mc.showWarning(WarningUI.WARNING_ONTRACK, !vobj.ontrack);
				// anzeige, wenn nicht in richtiger richtung
				myDisplay.warning_mc.showWarning(WarningUI.WARNING_INDIRECTION, !vobj.indirection);
				// geschwindigkeit anzeigen
				myDisplay.tachometer_mc.showSpeed(vobj.velocity.getLength() / Vehicle.VMAX);
				// drehzahl anzeigen
				myDisplay.revmeter_mc.rpm = vobj.getRelativeRPM();
				// infos anzeigen
//				showRaceInfos(vobj);
				
				// aktuelles streckenteil
				var trackpiece:TrackPiece = vobj.controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT);
				// anzahl streckenteile fuer vorschau
				var numpieces:Number = 4;
				// vorhersage ueber richtung der strecke
				var direction:Number = track.getDirectionPrediction(trackpiece, numpieces);
				// pfeile anzeigen
				myDisplay.direction_mc.showDirection(direction);
				
				// position fuer replay speichern
				myReplay.addPosition(myTime, pos);
				
				break;
			// computer
			case (Vehicle.TYPE_COMPUTER) :
//				// position des fahrzeugs
//				var pos:Point = vobj.position;
//				// streckenanzeige positionieren
//				trackui.centerTo(pos);
//				// fragen, ob auf strecke
//				var ontrack:Boolean = vobj.ontrack;
//				// infos anzeigen
//				showRaceInfos(ontrack);
			
				break;
			// unbekannt
			default :
				trace("onVehicleMove: " + vobj.type);
		}
		// auf ministrecke anzeigen
		minitrackui.showVehicle(vobj);
	}
	
	public function countLap(lap:Number ):Void
	{
		// rundenzeit speichern
		if (lap > 1) {
			// summe der bisherigen rundenzeiten
			var sum:Number = 0;
			// schleife ueber bisherige
			for (var i:Number = 0; i < lap - 1; i++) sum += myLapresults[i].getLaptime();
			// neue rundenzeit
			var laptime:Number = myTime - sum;
			// speichern
			myLapresults.push(new ChallengeLapresult(lap - 1, laptime));
			var res:ChallengeLapresult = myLapresults[myLapresults.length - 1];
			// aenderung zur letzten runde
			var tdiff:Number = 0;
			// ab der 2. runde ausrechnen
			if (lap > 2) {
				// unterschied der rundenzeiten
				tdiff = myLapresults[lap - 1].getLaptime() - myLapresults[lap - 2].getLaptime();
			}
			// vorzeichen
			var sign:String = (tdiff < 0 ? "-" : "+");
			// anzeigen
			myDisplay.counter_mc.showLaptime(TimeFormater.getMinutesSecondsMilliseconds(laptime), sign + TimeFormater.getMinutesSecondsMilliseconds(Math.abs(tdiff)));
		}
		// testen, ob rennen vorbei
		if (lap > LAPS) {
			// rennen beenden
			stopRace();
		} else {
			// runde anzeigen
			myDisplay.counter_mc.showLap(lap, LAPS); // LAPS - lap + 1
		}
	}
	
	public function stopRace():Void
	{
		// fahren der fahrzeuge beenden
		for (var i:String in myVehicles) {
			// aktuelles fahrzeug
			var vehicle:Vehicle = myVehicles[i];
			// stoppen
			vehicle.driving = false;
			// resetten
			vehicle.resetVehicle();
		}
		// beim taktgeber abmelden
		myStroke.removeListener(this);
		// rundenzeit fuer nullte runde loeschen
		myLapresults.shift();
		// callback aufrufen
		myCallback.apply(myCaller, [myTime, myLapresults, myReplay]);
	}
	
	public function resetRaceController():Void
	{
		// track loeschen
		track = null;
		// geladene strecke loeschen
		trackui.resetTrackUI();
		// minianzeige loeschen
		minitrackui = null;
		// trackfactory loeschen
		TrackFactory.getInstance().resetTrackFactory();
		// fahrzeuge auf der strecke
		myVehicles.splice(0);
		// kollisions detektor
		delete(myCollisionDetector);
		// rundenzeiten
		myLapresults.splice(0);
		// taktgeber
		myStroke = null;
		// loeschen
		_instance = null;
//		delete(_instance);
	}
	
//	public function getTrackpieceByPoint(point:Point ):TrackPiece
//	{
//		// laenge der strasse
//		var max:Number = myTrack.getNumTrackpieces();
//		// schleife ueber alle streckenteile
//		for (var i:Number = 0; i < max; i++) {
//			// aktuelles streckenteil
//			var trackpiece:TrackPiece = myTrack.getTrackpieceById(i);
//			// abbrechen, falls innerhalb
//			if (isPointOnTrackpiece(point, trackpiece) == true) return trackpiece;
//		}
//		// alle streckenteile negativ getestet
//		return null;
//	}
	
	public function getTrackpieceByPoint(point:Point ):TrackPiece
	{
		// streckenteile im raster rund um den punkt
		var pieces:Array = track.getTrackpiecesByPoint(point);
		// schleife ueber diese streckenteile
		for (var i:String in pieces) {
			// abbrechen, falls innerhalb
			if (isPointOnTrackpiece(point, pieces[i]) == true) return pieces[i];
		}
		// alle streckenteile negativ getestet
		return null;
	}
		
	private function RaceController()
	{
		// id der vom user gewaehlten strecke
		myTid = 0;
		// id des vom user gewaehlten fahrzeugs
		myCarid = 0;
		// caller, der das rennen startet
		myCaller = null;
		// callback, wenn rennen bereit zum start
		myCallback = null;
		// aktuelle strecke
		myTrack = null;
		// movieclip, das die strecke auf der buehne anzeigt
		myTrackUI = null;
		// movieclip, in dem die informationen fuer den user angezeigt werden
		myDisplay = null;
		// fahrzeuge auf der strecke
		myVehicles = new Array();
		// kollisions detektor
		myCollisionDetector = new CollisionDetector();
		// rennzeit
		myTime = 0;
		// rennrunde
		myLap = 0;
		// rundenzeiten
		myLapresults = new Array(new ChallengeLapresult(0, 0));
		// replay
		myReplay = new ChallengeReplay("");
		// taktgeber
		myStroke = _global.Stroke;
	}
	
	private function addVehicle(type:Number, pos:Point, angle:Number, carid:Number ):Void
	{
		// eindeutige id fuer neues fahrzeug
		var id:Number = myVehicles.length;
		// neues fahrzeug objekt
		var vobj;
		// neuer controller fuer fahrzeug
		var cobj:VehicleController;
		// movieclip, das fahrzeug auf buehne anzeigt
		var mc:VehicleUI;
		// je nach typ
		switch (type) {
			// user
			case (Vehicle.TYPE_USER) :
				// neues user-gesteuertes fahrzeug
				vobj = new VehicleUser(id);
				
				break;
			// computer
			case (Vehicle.TYPE_COMPUTER) :
				// neues computer-gesteuertes fahrzeug
				vobj = new VehicleComputer(id);
				// staerke
				if (id == 1) vobj.strength = VehicleComputer.STRENGTH_FAST;
				if (id == 2) vobj.strength = VehicleComputer.STRENGTH_MEDIUM;
				if (id == 3) vobj.strength = VehicleComputer.STRENGTH_SLOW;
			
				break;
			// unbekannt
			default :
				trace("addVehicle: " + type);
		}
		//  fahrzeug speichern
		myVehicles[id] = vobj;
		// movieclip, das fahrzeug auf buehne anzeigt
		mc = VehicleUI(myTrackUI.showVehicle("VehicleUI"));
		// fahrzeug initialisieren auf startposition
		vobj.initVehicle(mc, pos, angle / 180 * Math.PI);
		// movieclip initilisieren
		mc.initVehicleUI(vobj, carid);
		// einmal bewegen
		onVehicleMove(vobj);
	}
	
	private function checkCollisions():Void
	{
		// kollidierende fahrzeuge abfragen
		if (!myVehicles[0].controller.isVehicleOffRoad()) myCollisionDetector.handleCollisions();
		
//		myDisplay.control_txt.text = (colliders.length > 0 ? "kollision" : "");
//		// wenn fahrzeuge kollidieren, fahrzeuge informieren
//		if (colliders.length > 0) {
//				// kollisionen verarbeiten
//				myCollisionDetector.handleCollisions(colliders);
//		}
	}
	
	private function isPointOnTrackpiece(point:Point, tobj:TrackPiece ):Boolean
	{
		// entsprechendes polygon
		var polygon:Polygon = tobj.polygon;
		// testen
		var result:Boolean = LinearAlgebra.getInstance().isPointInPolygon(point, polygon);
		// zurueck geben
		return result;
	}
	
	private function showRaceInfos(vehicle:Vehicle ):Void
	{
		// position
		var position:Point = vehicle.position;
		// geschwindigkeit
		var velocity:Vector = vehicle.velocity;
		// beschleunigung
		var acceleration:Vector = vehicle.acceleration;
		// formatieren
		var str:String = "";
		str += "Position: x: + " + Math.round(position.x) + " y: " + Math.round(position.y);
		str += "\n";
		str += "Geschwindigkeit: " + velocity.getLength();
		str += "\n";
		str += "Beschleunigung: " + acceleration.getLength();
		str += "\n";
		str += "Auf Strecke: " + (vehicle.ontrack ? "JA" : "NEIN");
		str += "\n";
		str += "FPS: " + myStroke.fpsclip;
		
		// anzeigen
		_root.control_txt.text = str;
	}
}