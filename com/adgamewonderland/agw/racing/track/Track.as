/* 
 * Generated by ASDT 
*/ 

/*
klasse:			Track
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	18.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.track.*;

class com.adgamewonderland.agw.racing.track.Track {
	
	public static var DIRECTION_RIGHT:Number = 1;
	
	public static var DIRECTION_LEFT:Number = -1;
	
	public static var DIRECTION_STRAIGHT:Number = 0;
	
	private var myId:Number;
	
	private var myName:String;
	
	private var myWidth:Number;
	
	private var myHeight:Number;
	
	private var myNumPieces:Number;
	
	private var myRoad:Array;
	
	private var myOffRoad:Array;
	
	private var myGrid:TrackGrid;
	
	private var myStartPositions:Array;
	
	public function Track(id:Number, name:String, width:Number, height:Number, pnum:Number )
	{
		// eindeutige id
		myId = id;
		// name der strecke
		myName = name;
		// breite der strecke
		myWidth = width;
		// hoehe der strecke
		myHeight = height;
		// anzahl streckenteile
		myNumPieces = pnum;
		// streckenteile der strasse
		myRoad = new Array();
		// gespertte polygone ausserhalb der strasse
		myOffRoad = new Array();
		// raster zum schnelleren auffinden der streckenteile
		myGrid = new TrackGrid(width, height);
		// startpositionen fuer die einzelnen fahrzeuge
		myStartPositions = new Array();
	}
	
	public function get id():Number
	{
		// eindeutige id
		return myId;
	}
	
	public function get name():String
	{
		// name der strecke
		return myName;
	}
	
	public function get width():Number
	{
		// breite der strecke
		return myWidth;
	}
	
	public function get height():Number
	{
		// hoehe der strecke
		return myHeight;
	}
	
	public function get road():Array
	{
		// streckenteile der strasse
		return myRoad;
	}
	
	public function get offroad():Array
	{
		// gespertte polygone ausserhalb der strasse
		return myOffRoad;
	}
	
	public function get grid():TrackGrid
	{
		// raster zum schnelleren auffinden der streckenteile
		return myGrid;
	}
	
	public function set startpositions(arr:Array ):Void
	{
		// startpositionen fuer die einzelnen fahrzeuge
		myStartPositions = arr;
	}
	
	public function get startpositions():Array
	{
		// startpositionen fuer die einzelnen fahrzeuge
		return myStartPositions;
	}
	
	public function addTrackpiece(tobj:TrackPiece ):Void
	{
		// je nach typ des streckenteils
		switch (tobj.type) {
			// darf befahren werden
			case TrackPiece.TYPE_ROAD :
				// zur strasse hinzufuegen
				myRoad[tobj.id] = tobj;
				// ab dem zweiten verbindungsvektor hinzufuegen
				if (tobj.id > 0) addConnection(tobj);
				// beim letzten verbindungsvektor fuer erstes hinzufuegen
				if (tobj.id == getNumTrackpieces() - 1) addConnection(getTrackpieceById(0));
			
				break;
			// darf nicht befahren werden
			case TrackPiece.TYPE_OFFROAD :
				// zur offroad hinzufuegen
				myOffRoad[tobj.id] = tobj;
			
				break;
		}
		// zum raster hinzufuegen
		myGrid.addTrackpiece(tobj);
	}
	
	public function getTrackpieceById(id:Number ):TrackPiece
	{
		// entsprechendes streckenteil
		return myRoad[id];
	}
	
	public function getTrackpiecesByPoint(point:Point ):Array
	{
		// im raster gespeicherte streckenteile zurueck geben
		return myGrid.getTrackpiecesByPoint(point);
	}
	
	public function getNumTrackpieces():Number
	{
		// anzahl streckenteile zurueck geben
		return myNumPieces; // myRoad.length;
	}
	
	public function getDirectionPrediction(trackpiece:TrackPiece, numpieces:Number ):Number
	{
		// id des streckenteils
		var id:Number = trackpiece.id;
		// winkel, den die verbindungsvektoren der nachfolgenden streckenteile einschliessen
		var angle:Number = 0;
		// schleife ueber anzahl streckenteile
		for (var i:Number = 0; i < numpieces; i++) {
			// id des aktuellen streckenteils
			var id0:Number = id + i;
			// testen, ob am ende angekommen
			if (id0 >= getNumTrackpieces()) id0 -= getNumTrackpieces();
			// verbindungsvektor des aktuellen streckenteils
			var c0:Vector = getTrackpieceById(id0).connection;
			// id des naechsten streckenteils
			var id1:Number = id0 + 1;
			// testen, ob am ende angekommen
			if (id1 >= getNumTrackpieces()) id1 -= getNumTrackpieces();
			// verbindungsvektor des naechsten streckenteils
			var c1:Vector = getTrackpieceById(id1).connection;
			// winkel addieren
			angle += (c1.getAngle() - c0.getAngle());
		}
		// durchschnittswinkel
		angle /= numpieces;
		// umrechnen
		angle = angle / Math.PI * 180;
		// kurve?
		if (Math.abs(angle) > 15 && Math.abs(angle) < 50) {
			// rechts
			if (angle > 0) return DIRECTION_RIGHT;
			// links
			if (angle < 0) return DIRECTION_LEFT;
		} else {
			// geradeaus
			return DIRECTION_STRAIGHT
		}
	}
	
	private function addConnection(tobj:TrackPiece ):Void
	{
		// polygon des aktuellen streckenteils
		var p1:Polygon = tobj.polygon;
		// id des vorhergehenden streckenteils
		var pid:Number = (tobj.id > 0 ? tobj.id - 1 : getNumTrackpieces() - 1);
		// polygon des vorhergehenden streckenteils
		var p0:Polygon = getTrackpieceById(pid).polygon;
		// vektor zwischen den polygonen
		var conn:Vector = new Vector(p1.center.x - p0.center.x, p1.center.y - p0.center.y);
		// im vorhergenden streckenteil speichern
		getTrackpieceById(pid).connection = conn;
	}
	
}