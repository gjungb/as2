/* 
 * Generated by ASDT 
*/ 

/*
klasse:			TrackUI
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	28.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.graph.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

class com.adgamewonderland.agw.racing.track.TrackUI extends MovieClip implements Strokable {
	
	private static var PICPATH:String = "trackpics/racing_track_";
	
	private static var SCALE:Number = 0.4;
	
	private static var DIMENSIONS:Object = {x : 0, y : 0, width : 640, height : 480};
	
	private static var BORDER:Object = {x : 800, y : 600};

	private static var CENTER_ATTENUATION:Number = 4;
	
	private var myDimensions:Object;
	
	private var myBoxOuter:Polygon;
	
	private var myBoxInner:Polygon;
	
	private var myCenter:Point;
	
	private var myTargetPosition:Point;
	
	private var myTargetVector:Vector;
	
	private var myStroke:StrokeUI;
	
	private var trackpic_mc:MovieClip;
	
	public function TrackUI()
	{
		// beim racecontroller anmelden
		RaceController.getInstance().trackui = this;
		// dimensionen
		myDimensions = {x : DIMENSIONS.x, y : DIMENSIONS.y, width : DIMENSIONS.width, height : DIMENSIONS.height};
		// umrandende box
		myBoxOuter = new Polygon();
		// innere box
		myBoxInner = new Polygon();
		// zielpunkt, zu dem die streckenanzeige beim zentrieren bewegt werden soll
		myTargetPosition = new Point(0, 0);
		// vektor zwischen mittelpunkt und zielpunkt
		myTargetVector = new Vector(0, 0);
		// taktgeber
		myStroke = _global.Stroke;
	}
	
	public function resetTrackUI():Void
	{
		// strecke entladen
		trackpic_mc.unloadMovie();
	}
	
	public function initBoxInner(width:Number, height:Number ):Void
	{
		// breite der box
		var xdiff:Number = width - BORDER.x * 2;
		// hoehe der box
		var ydiff:Number = height - BORDER.y * 2;
		// vier punkte hinzufuegen
		myBoxInner.addPoint(new Point(BORDER.x, BORDER.y));
		myBoxInner.addPoint(new Point(BORDER.x + xdiff, BORDER.y));
		myBoxInner.addPoint(new Point(BORDER.x + xdiff, BORDER.y + ydiff));
		myBoxInner.addPoint(new Point(BORDER.x, BORDER.y + ydiff));
//		// malbrett
//		var db:DrawingBoard = new DrawingBoard(this);
//		// auf buehne anzeigen
//		db.drawPolygon(myBoxInner, false);
	}
	
	public function loadTrackpic(tid:Number ):Void
	{
		// neues mc
		trackpic_mc = this.createEmptyMovieClip("trackpic_mc", 1);
		// name der swf
		var swf:String = PICPATH + tid + ".swf";
		// moviecliploader
		var loader_mcl:MovieClipLoader = new MovieClipLoader();
		// listener fuer moviecliploader
		var lsnr:Object = new Object();
		// referenz auf trackui
		lsnr.trackui = this;
		// start des ladens
		lsnr.onLoadStart = function (target_mc:MovieClip ) {
		};
		// waehrend des ladens
		lsnr.onLoadProgress = function (target_mc:MovieClip, bytesLoaded:Number, bytesTotal:Number ) {
		};
		// laden beendet
		lsnr.onLoadComplete = function (target_mc:MovieClip ) {
		};
		// geladene swf initialisiert
		lsnr.onLoadInit = function (target_mc:MovieClip ) {
			// callback
			this.trackui.onTrackpicLoaded();
		};
		// listener registrieren
		loader_mcl.addListener(lsnr);
		// laden
		loader_mcl.loadClip(swf, trackpic_mc);
	}
	
	public function onTrackpicLoaded():Void
	{
		// skalieren und dimensionen anpassen
		zoomTo(SCALE);
		// umrandende box initialisieren
		initBoxOuter();
		// mittelpunkt der umrandenden box
		myCenter = myBoxOuter.center; // new Point(DIMENSIONS.x + DIMENSIONS.width /2, DIMENSIONS.y + DIMENSIONS.height /2);
		// callback
		RaceController.getInstance().onTrackpicLoaded();
	}
	
	public function zoomTo(scale:Number ):Void
	{
		// skalieren
		_xscale = _yscale = scale * 100;
		// streckenbild invers skalieren
		trackpic_mc._xscale = trackpic_mc._yscale = TrackFactory.SCALE * 100;
		// dimensionen anpassen
		myDimensions.width *= 1 / scale;
		myDimensions.height *= 1 / scale;
	}
	
	public function startTrack():Void
	{
		// beim taktgeber anmelden
		myStroke.addListener(this);
	}
	
	public function stopTrack():Void
	{
		// beim taktgeber abmelden
		myStroke.removeListener(this);
	}
	
	public function centerTo(point:Point ):Void
	{
		// x-position zielpunkt
		myTargetPosition.x = point.x;
		// y-position zielpunkt
		myTargetPosition.y = point.y;
	}
	
	public function onUpdateStroke():Void
	{
		// x-abstand zielpunkt
		var xdiff:Number = (myCenter.x - myTargetPosition.x) * _xscale / 100 - _x;
		// y-abstand zielpunkt
		var ydiff:Number = (myCenter.y - myTargetPosition.y) * _yscale / 100 - _y;
		// vektor zwischen mittelpunkt und zielpunkt aktualisieren
		myTargetVector.setDiff(xdiff, ydiff);
		// testen, ob zielpunkt ausserhalb der inneren box
		if (isPointInBoxInner(myTargetPosition) == false) {
			// algebra
			var algebra:LinearAlgebra = LinearAlgebra.getInstance();
			// links bedeutet ausserhalb
			var outside:Number = LinearAlgebra.POINT_LINE_RELATION_LEFT;
			// oben oder unten raus
			if (algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[0]) == outside || algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[2]) == outside) {
				// keine bewegung in y-richtung
				myTargetVector.setDiff(myTargetVector.xdiff, 0);
			}
			// rechts oder links raus
			if (algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[1]) == outside || algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[3]) == outside) {
				// keine bewegung in x-richtung
				myTargetVector.setDiff(0, myTargetVector.ydiff);
			}
		}
		// gedaempft positionieren
		_x += myTargetVector.xdiff / CENTER_ATTENUATION;
		_y += myTargetVector.ydiff / CENTER_ATTENUATION;
	}
	
	public function showVehicle(identifier:String ):MovieClip
	{
		// tiefe
		var depth:Number = getNextHighestDepth();
		// auf buehne
		var mc:MovieClip = attachMovie(identifier, depth.toString(), depth);
		// zurueck geben
		return mc;
	}
	
	public function showTrack(track:Track ):Void
	{
//		// schleife ueber alle streckenteile, die befahren werden duerfen
//		for (var i:Number = 0; i <= track.getNumTrackpieces(); i++) {
//			// aktuelles streckenteil
//			var trackpiece:TrackPiece = track.getTrackpieceById(i);
//			// zeichnen
//			drawTrackpiece(trackpiece);
//		}
		// schleife ueber alle streckenteile, die nicht befahren werden duerfen
		for (var j:Number = 0; j < track.offroad.length; j++) {
			// aktuelles streckenteil
			var trackpiece:TrackPiece = track.offroad[j];
			// zeichnen
			drawTrackpiece(trackpiece);
		}
	}
	
	private function drawTrackpiece(tobj:TrackPiece ):Void
	{
		// malbrett
		var db:DrawingBoard = new DrawingBoard(this);
		// polygon
		var polygon:Polygon = tobj.polygon;
		// auf buehne anzeigen
		db.drawPolygon(polygon, false);
	}
	
	private function initBoxOuter():Void
	{
		// vier punkte hinzufuegen
		myBoxOuter.addPoint(new Point(myDimensions.x, myDimensions.y));
		myBoxOuter.addPoint(new Point(myDimensions.x + myDimensions.width, myDimensions.y));
		myBoxOuter.addPoint(new Point(myDimensions.x + myDimensions.width, myDimensions.y + myDimensions.height));
		myBoxOuter.addPoint(new Point(myDimensions.x, myDimensions.y + myDimensions.height));
		// malbrett
		var db:DrawingBoard = new DrawingBoard(_root);
		// auf buehne anzeigen
//		db.drawPolygon(myBoxOuter, false);
	}
	
	private function isPointInBoxInner(point:Point ):Boolean
	{
		// testen
		var result:Boolean = LinearAlgebra.getInstance().isPointInPolygon(point, myBoxInner);
		// zurueck geben
		return result;
	}
}