/* 
 * Generated by ASDT 
*/ 

/*
klasse:			Track
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		21.05.2005
zuletzt bearbeitet:	21.05.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.graph.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

class com.adgamewonderland.agw.racing.track.TrackGrid {
	
	public static var NUM_ROWS:Number = 12;
	
	public static var NUM_COLUMNS:Number = 20;
	
	private var myWidth:Number;
	
	private var myHeight:Number;
	
	private var myCells:Array;
	
	private var myBoxes:Array;
	
	public function TrackGrid(width:Number, height:Number )
	{
		// breite des rasters
		myWidth = width;
		// hoehe des rasters
		myHeight = height;
		// zellen des rasters
		myCells = initCells();
		// polygonboxen des rasters
		myBoxes = initBoxes();
	}
	
	public function get cells():Array
	{
		// zellen des rasters
		return myCells;
	}
	
	public function addTrackpiece(tobj:TrackPiece ):Void
	{
		// polygon des streckenteils
		var polygon:Polygon = tobj.polygon;
		// anzahl ecken im polygon
		var numpoints:Number = polygon.getNumPoints();
		// aktuelle zeile
		var row:Number;
		// aktuelle spalte
		var column:Number;
		// kleinste und groesste zeile
		var rows:Object = {min : Number.MAX_VALUE, max : 0};
		// kleinste und groesste spalte
		var columns:Object = {min : Number.MAX_VALUE, max : 0};
		// schleife ueber alle ecken, um kleinste und groesste zellen zu finden
		for (var i:Number = 1; i <= numpoints; i++) {
			// aktuelle ecke
			var point:Point = polygon.getPoint(i);
			// zeile, in der die ecke liegt
			row = getRowByPosition(point.y);
			// spalte, in der die ecke liegt
			column = getColumnByPosition(point.x);
			
			// kleinste und groesste zeile updaten
			if (row < rows.min) rows.min = row;
			if (row > rows.max) rows.max = row;
			// kleinste und groesste spalte updaten
			if (column < columns.min) columns.min = column;
			if (column > columns.max) columns.max = column;
		}
		
		// schleife ueber alle zeilen zwischen der kleinsten und groessten zeile
		for (row = rows.min; row <= rows.max; row++) {
			// schleife ueber alle spalten zwischen der kleinsten und groessten spalte
			for (column = columns.min; column <= columns.max; column++) {
				// testen, ob streckenteil an dieser stelle noch nicht gespeichert
				if (!isValueInCell(tobj, row, column)) {
					// streckenteil speichern
					addCellValue(tobj, row, column);
				}
			}
		}
	}
	
	public function getTrackpiecesByPoint(point:Point ):Array
	{
		// zeile, in der der punkt liegt
		var row:Number = getRowByPosition(point.y);
		// spalte, in der der punkt liegt
		var column:Number = getColumnByPosition(point.x);
		// inhalt der zelle zurueck geben
		return myCells[row][column];
	}
	
	private function initCells():Array
	{
		// zweidimensionales array
		var cells:Array = new Array(NUM_ROWS);
		// schleife ueber alle zeilen
		for (var i:Number = 0; i < cells.length; i++) {
			// neue spalten
			cells[i] = new Array(NUM_COLUMNS);
			// schleife ueber alle spalten
			for (var j:Number = 0; j < cells[i].length; j++) {
				// leer initialisieren
				cells[i][j] = new Array();
			}
		}
		// zurueck geben
		return cells;
	}
	
	private function initBoxes():Array
	{
		// lijneares array mit polygonen
		var boxes:Array = new Array(NUM_ROWS * NUM_COLUMNS);
		// breite eines polygons
		var width:Number = myWidth / NUM_COLUMNS;
		// hoehe eines polygons
		var height:Number = myHeight / NUM_ROWS;
		// malbrett
		var db:DrawingBoard = new DrawingBoard(RaceController.getInstance().trackui);
		// schleife ueber alle zeilen
		for (var i:Number = 0; i < NUM_ROWS; i++) {
			// schleife ueber alle spalten
			for (var j:Number = 0; j < NUM_COLUMNS; j++) {
				// neues polygon
				var polygon:Polygon = new Polygon();
				// vier eckpunkte
				polygon.addPoint(new Point(j * width, i * height));
				polygon.addPoint(new Point((j + 1) * width, i * height));
				polygon.addPoint(new Point((j + 1) * width, (i + 1) * height));
				polygon.addPoint(new Point(j * width, (i + 1) * height));
				// speichern
				boxes.push(polygon);
				// auf buehne anzeigen
//				db.drawPolygon(polygon, false);
			}
		}
		// zurueck geben
		return boxes;
	}
	
	private function getRowByPosition(ypos:Number ):Number
	{
		// gesuchte zeile
		var row:Number = Math.floor(ypos / (myHeight / NUM_ROWS));
		// zurueck geben
		return row;
	}
	
	private function getColumnByPosition(xpos:Number ):Number
	{
		// gesuchte spalte
		var column:Number = Math.floor(xpos / (myWidth / NUM_COLUMNS));
		// zurueck geben
		return column;
	}
	
	private function isValueInCell(val:Object, row:Number, column:Number ):Boolean
	{
		// zu durchsuchende zelle
		var cell:Array = myCells[row][column];
		// schleife ueber inhalt
		for (var i:String in cell) {
			// erfolgreich, wenn wert gefunden
			if (cell[i] == val) return true;
		}
		// nicht gefunden
		return false;
	}
	
	private function addCellValue(val:Object, row:Number, column:Number ):Void
	{
		// wert speichern
		myCells[row][column].push(val);
	}
}