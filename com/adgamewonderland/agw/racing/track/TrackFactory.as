/* 
 * Generated by ASDT 
*/ 

/*
klasse:			TrackFactory
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	18.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.util.*;

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.track.*;

class com.adgamewonderland.agw.racing.track.TrackFactory {
	
	private static var _instance:TrackFactory;
	
	public static var SCALE:Number = 2;
	
	private static var XMLPATH:String = "tracklayouts/racing_track";
	
	private static var SOURCE_XML:Number = 1;
	
	private static var SOURCE_REMOTING:Number = 2;
	
	private var mySource:Number = SOURCE_XML;
	
	private var myTracks:Array;
	
	private var myCurrentTrackId:Number;
	
	private var myCaller:Object;
	
	private var myCallback:String;

	public static function getInstance():TrackFactory
	{
		if (_instance == null) {
			_instance = new TrackFactory();
		}
		return _instance;
	}
	
	public function resetTrackFactory():Void
	{
		// loeschen
		delete(_instance);
	}
	
	public function setSource(source:Number ):Void
	{
		// gewuenschte datenquelle
		mySource = source;
	}
	
	public function getTrack(id:Number, caller:Object, callback:String ):Void
	{
//		// testen, ob track bereits geladen
//		if (myTracks[id] instanceof Track) {
//			// zurueck geben
//			return myTracks[id];	
//		}
		// id der zu ladenden strecke
		myCurrentTrackId = id;
		// caller, der einen track haben moechte
		myCaller = caller;
		// callback nach dem laden und parsen des gewuenschten tracks
		myCallback = callback;
		// road laden
		loadRoad(TrackPiece.TYPE_ROAD);
	}
	
	private function TrackFactory()
	{
		// bisher geladene tracks
		myTracks = new Array();
		// caller, der einen track haben moechte
		myCaller = null;
		// callback nach dem laden und parsen des gewuenschten tracks
		myCallback = "";
	}
	
	private function loadRoad(type:Number ):Void
	{
		// je nach datenquelle
		switch (mySource) {
			// xml
			case SOURCE_XML :
				// dateiname
				var file:String = XMLPATH;
				// loader
				var conn:XMLConnector = new XMLConnector(this, "");
				// callback
				var callback:String = "";
				// je nach typ
				switch (type) {
					// darf befahren werden
					case TrackPiece.TYPE_ROAD :
						// dateiname
						file += myCurrentTrackId + "_road.xml";
						// callback
						callback = "onRoadLoaded";
					
						break;
					// darf nicht befahren werden
					case TrackPiece.TYPE_OFFROAD :
						// dateiname
						file += myCurrentTrackId + "_offroad.xml";
						// callback
						callback = "onOffRoadLoaded";
					
						break;
					
				}
				// dateiname uebergeben
				conn.setUrl(file);
				// laden
				conn.loadXML(callback);
			
				break;
			// remoting
			case SOURCE_REMOTING :
			
				break;
			// unbekannt
			default :
				trace("loadRoad: " + mySource);
		}
	}
	
	private function onRoadLoaded(desc:XML ):Void
	{
		// road parsen
		var track:Track = parseRoad(desc);
		// speichern
		myTracks[myCurrentTrackId] = track;
		// offroad laden
		loadRoad(TrackPiece.TYPE_OFFROAD);
		// an caller zurueck geben
//		myCaller[myCallback](track);
	}
	
	private function onOffRoadLoaded(desc:XML ):Void
	{
		// track
		var track:Track = myTracks[myCurrentTrackId];
		// offroad parsen
		parseOffRoad(desc, track);
		// startpositionen laden
		loadStartPositions();
		// an caller zurueck geben
//		myCaller[myCallback](track);
	}
	
	private function loadStartPositions():Void
	{
		// je nach datenquelle
		switch (mySource) {
			// xml
			case SOURCE_XML :
				// loader
				var conn:XMLConnector = new XMLConnector(this, "");
				// dateiname
				var file:String = XMLPATH + myCurrentTrackId + "_start.xml";;
				// callback
				var callback:String = "onStartPositionsLoaded";
				// dateiname uebergeben
				conn.setUrl(file);
				// laden
				conn.loadXML(callback);
			
				break;
			// remoting
			case SOURCE_REMOTING :
			
				break;
			// unbekannt
			default :
				trace("loadStartPositions: " + mySource);
		}
	}
	
	private function onStartPositionsLoaded(desc:XML ):Void
	{
		// track
		var track:Track = myTracks[myCurrentTrackId];
		// startpositionen parsen
		parseStartPositions(desc, track);
		// an caller zurueck geben
		myCaller[myCallback](track);
	}
	
	private function parseRoad(xmlobj:XML ):Track
	{
		// track
		var trackXML:XMLNode = xmlobj.firstChild;
		// id
		var tid:Number = Number(trackXML.attributes["id"]);
		// name
		var name:String = trackXML.attributes["name"];
		// breite
		var width:Number = Number(trackXML.attributes["width"]) * SCALE;
		// hoehe
		var height:Number = Number(trackXML.attributes["height"]) * SCALE;
		// streckenteile
		var pieces:Array = trackXML.childNodes;
		// neuer track
		var track:Track = new Track(tid, name, width, height, pieces.length);
		
		// schleife ueber alle streckenteile
		for (var i:Number = 0; i < pieces.length; i++) {
			// aktuelles streckenteil
			var pieceXML:XMLNode = pieces[i];
			// id
			var pid:Number = Number(pieceXML.attributes["id"]);
			// neues trackpiece, das befahren werden darf
			var trackpiece:TrackPiece = new TrackPiece(pid, TrackPiece.TYPE_ROAD);
			// koordinaten der eckpunkte
			var points:Array = pieceXML.childNodes;
			// neues polygon zum streckenteil hinzufuegen
			trackpiece.polygon = new Polygon(points.length);
			// schleife ueber alle eckpunkte
			for (var j:Number = 0; j < points.length; j++) {
				// aktueller eckpunkt
				var point:Point = new Point(Number(points[j].attributes["x"]) * SCALE, Number(points[j].attributes["y"]) * SCALE);
				// zum polygon hinzufuegen
				trackpiece.polygon.addPoint(point);
			}
			// zum track hinzufuegen
			track.addTrackpiece(trackpiece);
		}
		
		// track zurueck geben
		return track;
	}
	
	private function parseOffRoad(xmlobj:XML, track:Track ):Void
	{
		// track
		var trackXML:XMLNode = xmlobj.firstChild;
		
		// streckenteile
		var pieces:Array = trackXML.childNodes;
		// schleife ueber alle streckenteile
		for (var i:Number = 0; i < pieces.length; i++) {
			// aktuelles streckenteil
			var pieceXML:XMLNode = pieces[i];
			// id
			var pid:Number = Number(pieceXML.attributes["id"]);
			// neues trackpiece, das nicht befahren werden darf
			var trackpiece:TrackPiece = new TrackPiece(pid, TrackPiece.TYPE_OFFROAD);
			// koordinaten der eckpunkte
			var points:Array = pieceXML.childNodes;
			// neues polygon zum streckenteil hinzufuegen
			trackpiece.polygon = new Polygon(points.length);
			// schleife ueber alle eckpunkte
			for (var j:Number = 0; j < points.length; j++) {
				// aktueller eckpunkt
				var point:Point = new Point(Number(points[j].attributes["x"]) * SCALE, Number(points[j].attributes["y"]) * SCALE);
				// zum polygon hinzufuegen
				trackpiece.polygon.addPoint(point);
			}
			// zum track hinzufuegen
			track.addTrackpiece(trackpiece);
		}
	}
	
	private function parseStartPositions(xmlobj:XML, track:Track ):Void
	{
		// track
		var trackXML:XMLNode = xmlobj.firstChild;
		
		// startpositionen der fahrzeuge
		var startpositions:Array = new Array();
		// fahrzeuge
		var vehicles:Array = trackXML.childNodes;
		// schleife ueber alle fahrzeuge
		for (var i:Number = 0; i < vehicles.length; i++) {
			// aktuelles fahrzeug
			var vehicleXML:XMLNode = vehicles[i];
			// in object umformen
			var pos:Object = (new XMLConnector()).parseXMLNode(vehicleXML);
			// speichern
			startpositions.push(pos);
		}
		// zum track hinzufuegen
		track.startpositions = startpositions;
	}
}