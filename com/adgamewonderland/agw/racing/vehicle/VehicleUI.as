/* 
 * Generated by ASDT 
*/ 

/*
klasse:			VehicleUser
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	27.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.graph.*;

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleUI extends MovieClip {
	
	public static var NUMCARS:Number = 6;
	
	private static var SHADOWDIFF:Object = {x : 2, y : 2};
	
	private static var TIME_COLOR:Number = 10000;
	
	private var myVehicle:Vehicle;
	
	private var myInterval:Number;
	
	private var myCollisionDistance:Number;
	
	public var color_mc:MovieClip;
	
	public var shadow_mc:MovieClip;
	
	public function VehicleUI()
	{
		super();
		// fahrzeug
		myVehicle = null;
		// interval
		myInterval = 0;
		// abstand zweier fahrzeuge, unterhalb dem kollision detailliert getestet wird
		myCollisionDistance = shadow_mc._width * 2;
	}
	
	public function get collisiondistance():Number
	{
		// abstand zweier fahrzeuge, unterhalb dem kollision detailliert getestet wird
		return myCollisionDistance;
	}
	
	public function initVehicleUI(vobj:Vehicle, carid:Number ):Void
	{
		// fahrzeug
		myVehicle = vobj;
		// modell anzeigen
		gotoAndStop(carid);
		// user fahrzeug farbe anzeigen
		if (vobj.type == Vehicle.TYPE_USER) {
			// farbe einblenden
			showColor(true);
			// nach pause wieder ausblenden
			setInterval(this, "showColor", TIME_COLOR, false);
		} else {
			// farbe ausblenden
			showColor(false);
		}
		onEnterFrame = function() {
			myVehicle.onUpdateStroke();
		};
	}
	
	public function resetVehicleUI():Void
	{
		delete(onEnterFrame);	
	}
	
	public function setPosition(point:Point ):Void
	{
		// auf buehne positionieren
		_x = point.x;
		_y = point.y;
	}
	
	public function setRotation(angle:Number ):Void
	{
		// auf buehne drehen
		_rotation = angle;
		// schatten positionieren
		updateShadow();
	}
	
	public function getEdgeGlobal():Polygon
	{
		// umrandung des fahrzeugs
		var edge:Polygon = new Polygon(4);
		// grenzen relativ zur anzeige der strecke
		var bounds:Object = shadow_mc.getBounds(this); // _parent
		// links oben
			var pt1:Object = {x : bounds.xMin, y : bounds.yMin};
			this.localToGlobal(pt1);
			edge.addPoint(new Point(pt1.x, pt1.y));
//		edge.addPoint(new Point(bounds.xMin, bounds.yMin));
		// rechts oben
			var pt2:Object = {x : bounds.xMax, y : bounds.yMin};
			this.localToGlobal(pt2);
			edge.addPoint(new Point(pt2.x, pt2.y));
//		edge.addPoint(new Point(bounds.xMax, bounds.yMin));
		// rechts unten
			var pt3:Object = {x : bounds.xMax, y : bounds.yMax};
			this.localToGlobal(pt3);
			edge.addPoint(new Point(pt3.x, pt3.y));
//		edge.addPoint(new Point(bounds.xMax, bounds.yMax));
		// links unten
			var pt4:Object = {x : bounds.xMin, y : bounds.yMax};
			this.localToGlobal(pt4);
			edge.addPoint(new Point(pt4.x, pt4.y));
//		edge.addPoint(new Point(bounds.xMin, bounds.yMax));
		
		// zurueck geben
		return edge;
	}
	
	private function showColor(bool:Boolean ):Void
	{
		// farbe ein- / ausblenden
		color_mc._visible = bool;
		// interval loeschen
		clearInterval(myInterval);
	}
	
	private function updateShadow():Void
	{
		// position des fahrzeugs
		var pos:Object = {x : myVehicle.position.x, y : myVehicle.position.y};
		// in globale koordinaten relativ zur anzeige der strecke
		_parent.localToGlobal(pos);
		// schatten daneben
		pos.x += SHADOWDIFF.x;
		pos.y += SHADOWDIFF.y;
		// in lokale koordinaten
		globalToLocal(pos);
		// positionieren
		shadow_mc._x = pos.x;
		shadow_mc._y = pos.y;
	}
}