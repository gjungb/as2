/* 
 * Generated by ASDT 
*/

/*
klasse:			VehicleTest2
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		04.06.2005
zuletzt bearbeitet:	09.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleTest2 extends Vehicle {
	
	private static var KEYS:Object = {left : Key.LEFT, right : Key.RIGHT, up : Key.UP, down : Key.SPACE};
	
	private static var AMIN:Number = 1e-6 / ATTENUATION; // minimale linearbeschleunigung
	
	private static var AMAX:Number = 8 / ATTENUATION; // maximale linearbeschleunigung
	
	private static var AUP_ON:Number = 18 / ATTENUATION; // betrag beschleunigungsvektor beim gas geben auf strecke
	
	private static var AUP_OFF:Number = 14 / ATTENUATION; // betrag beschleunigungsvektor beim gas geben neben strecke
	
	private static var ABRAKE:Number = 14 / ATTENUATION; // betrag beschleunigungsvektor beim bremsen
	
	private static var AFRICTION_ON:Number = 8 / ATTENUATION; // betrag beschleunigungsvektor bei reibung auf strecke
	
	private static var AFRICTION_OFF:Number = 12 / ATTENUATION; // betrag beschleunigungsvektor bei reibung neben strecke
	
	private static var VREVERSE:Number = VMAX / 4; // maximale geschwindigkeit beium rueckwaerts fahren
	
	private static var STEER_LEFT:Number = -1; // lenken nach links
	
	private static var STEER_RIGHT:Number = 1; // lenken nach rechts
	
	private static var STEER_ANGLE:Number = 12 / 180 * Math.PI; // lenkwinkel je update
	
	private static var STEER_TIME:Number = 1500; // lenkzeit bis erreichen lenkwinkel
	
	private static var STEER_ANGLE_MAX:Number = 80; // maximaler lenkwinkel
	
	private static var STEER_VMIN:Number = VMAX * 0.05; // mindestgeschwindigkeit, ab der lenken erlaubt
	
	private static var BRAKE_TIME:Number = 1000; // bremszeit bis auftreten bremsspuren
	
	private static var BRAKE_VMIN:Number = VMAX * 0.8; // mindestgeschwindigkeit, ab der bremsspuren
	
	private static var SLIDE_ANGLE:Number = 0.5; // mindestlenkwinkelverhaeltnis, ab dem sliden
	
	private static var SLIDE_VMIN:Number = VMAX * 0.5; // mindestgeschwindigkeit, ab der sliden
	
	private var isReverse:Boolean;
	
	private var myFriction:Vector;
	
	private var myBrake:Vector;
	
	private var mySteerTimeStart:Number;
	
	private var mySteerDirection:Number;
	
	private var myBrakeTimeStart:Number;
	
	private var myBrakeStatus:Boolean;
	
	private var myLap:Number;
	
	private var myLastLap:Number;
	
	public function VehicleTest2() {
		// eigenschaften des vehicle
		super.constructor.apply(super, arguments);
		// typ des vehicles
		type = TYPE_USER;
		// faehrt das fahrzeug rueckwaerts
		isReverse = false;
		// reibungsvektor
		myFriction = new Vector(1, 1);
		// auf laenge auf strecke
		myFriction.setLength(AFRICTION_ON);
		// bremsvektor
		myBrake = new Vector(1, 1);
		// auf laenge
		myBrake.setLength(ABRAKE);
		// startzeitpunkt beim lenken
		mySteerTimeStart = getTimer();
		// letzte richtung beim lenken
		mySteerDirection = 0;
		// startzeitpunkt beim bremsen
		myBrakeTimeStart = getTimer();
		// status beim bremsen
		myBrakeStatus = false;
		// rennrunde
		myLap = 0;
		// vorherige rennrunde
		myLastLap = 0;
		// testendruck ueberwachen
		Key.addListener(this);
	}
	
	public function initVehicle(mc:VehicleUI, point:Point, angle:Number ):Void
	{
		// methode des vehicle
		super.initVehicle.apply(super, arguments);
		// reibungsvektor drehen
		myFriction.setAngle(velocity.getAngle() + Math.PI);
		// bremsvektor drehen
		myBrake.setAngle(velocity.getAngle() + Math.PI);
	}
	
	public function onUpdateStroke():Void
	{
		// testen, ob fahrzeug auf strecke
		ontrack = controller.isVehicleOnTrack();
		// checken, ob beschleunigen
		checkAccelerating();
		// checken, ob lenken
		checkSteering();
		// was passiert, wenn das fahrzeug nicht auf der strecke ist
		if (!ontrack) whileNotOnTrack();
		// geschwindigkeit updaten
		updateVelocity();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// sound updaten
		updateSound();
		// controller informieren
		RaceController.getInstance().onVehicleMove(this);
	}
	
	public function onChangeTrackpiece():Void
	{
		// testen, ob ueber ziel gefahren
		if (controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT).id == 0) {
			if (myLap == myLastLap) myLap ++;
			RaceController.getInstance().countLap(myLap);
		}
		// testen, ob am ende
		if (controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT).id == RaceController.getInstance().track.getNumTrackpieces() - 1) {
			if (myLap != myLastLap) myLastLap ++;
		}
	}
	
	public function onKeyDown():Void
	{
	}
	
	public function onKeyUp():Void
	{
		// bremsen beendet
		if (Key.getCode() == KEYS.down) {
			// status beim bremsen
			myBrakeStatus = false;
			// sound ausblenden
			mySoundBrake.stop();
		}
	}
	
	private function checkAccelerating():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// aktuelle geschwindigkeit
		var v:Number = velocity.getLength();
		
		// beschleunigen
		if (kd(KEYS.up)) {
			// geschwindigkeit erhoehen, wenn 1. auf der strecke oder 2. ausserhalb der strecke und langsam genug
			if (ontrack || (!ontrack && v <= VMAX_OFF)) v += (ontrack ? AUP_ON : AUP_OFF);
			// testen, ob rueckwaerts
			if (isReverse) {
				// geschwindigkeit drehen
				velocity.setAngle(angle);
				// nicht mehr rueckwaerts
				isReverse = false;
			}
		}
		
		// bremsen
		if (kd(KEYS.down)) {
			// testen, ob vorwaerts
			if (isReverse == false) {
				// testen, ob schnell genug
				if (Math.floor(velocity.getLength() / VMIN) > 1) {
					// geschwindigkeit reduzieren
					v -= ABRAKE;
					
					// testen, ob gerade mit bremsen begonnen
					if (myBrakeStatus == false) {
							// status beim bremsen
							myBrakeStatus = true;
						// testen, ob schnell genug
						if (velocity.getLength() > BRAKE_VMIN) {
							// startzeitpunkt beim bremsen
							myBrakeTimeStart = getTimer();
						}
					// testen, ob bremsspur
					} else if (getTimer() - myBrakeTimeStart > BRAKE_TIME) {
						// sound abspielen
						mySoundBrake.start(0, 10);
					}
				} else if (!kd(KEYS.up) && myBrakeStatus == false) {
					// geschwindigkeit drehen
					velocity.setAngle(angle + Math.PI);
					// rueckwaerts
					isReverse = true;
				}
			// rueckwaerts
			} else {
				// beschleunigen
				v += (ontrack ? AUP_ON - AFRICTION_ON : AUP_OFF - AFRICTION_OFF);
				// gleichmaessige geschwindigkeit
				if (v > VREVERSE) v = VREVERSE;
			}
		} else {
			// reibung
			// geschwindigkeit reduzieren
			v -= ((ontrack ? AFRICTION_ON : AFRICTION_OFF)); //  * velocity.getLength() / VMAX
		}
		
		// testen, ob mindestgeschwindigkeit unterschritten wuerde
		if (v < VMIN) v = VMIN;
		// neue geschwindigkeit setzen
		velocity.setLength(v);
	}
	
	private function checkSteering():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// lenkwinkel
		var sangle:Number;
		// lenkrichtung
		var dirsteer:Number;
		// links
		if (kd(KEYS.left)) {
			dirsteer = STEER_LEFT;
		// rechts
		} else if (kd(KEYS.right)) {
			dirsteer = STEER_RIGHT;
		// geradeaus
		} else {
			dirsteer = 0;
		}
		// lenkwinkel ermitteln
		sangle = getSteerAngle(dirsteer);
		// testen, ob rueckwaerts
		if (isReverse) sangle *= -1;
		// geschwindigkeit drehen
		velocity.rotateBy(sangle);
		// drehwinkel drehen
		angle += sangle;
		// testen, ob zu gross oder klein
		if (angle > 2 * Math.PI) angle -= 2 * Math.PI;
		if (angle < -2 * Math.PI) angle += 2 * Math.PI;
		
		
//		// sliden ?
//		if (Math.abs(sangle / STEER_ANGLE) > SLIDE_ANGLE) { // dirsteer != 0
//			myAngleSlide = (velocity.getLength() / VMAX) * (sangle / STEER_ANGLE) * 0.5;
//		} else {
//			myAngleSlide *= 0.6;
//		}
		
		// alternativ:
//		// lenkvektor erstellen
//		var asteer:Vector = new Vector(1, 1);
//		// mit richtung multiplizieren, um geradeaus zu elimnieren
//		acceleration.multiplyBy(Math.abs(dirsteer));
//		// laenge abhaengig vom lenkwinkel
//		if (dirsteer != 0) {
//			acceleration.setLength(2 * sangle / STEER_ANGLE + 1e-12);
//			// lotrecht zur geschwindigkeit
//			acceleration.setAngle(velocity.getAngle() + dirsteer * Math.PI / 2);
//		} else {
//			acceleration.multiplyBy(0.8);
//		}
//		// als beschleunigung speichern
//		acceleration.setDiff(asteer.xdiff, asteer.ydiff);
	}
	
	private function getSteerAngle(direction:Number ):Number
	{
		// abbrechen, wenn zu langsam
		if (velocity.getLength() < STEER_VMIN) return 0;
		// testen, ob richtung gewechselt
		if (direction != mySteerDirection) {
			// letzte richtung beim lenken
			mySteerDirection = direction;
			// startzeitpunkt beim lenken
			mySteerTimeStart = getTimer();
		}
		// dauer des lenkens
		var time:Number = getTimer() - mySteerTimeStart;
		// lenkwinkel (betrag)
		var sangle:Number = time / STEER_TIME * STEER_ANGLE;
		// deckeln
		if (sangle > STEER_ANGLE) sangle = STEER_ANGLE;
		// links / rechts
		sangle *= direction;
		// lenkung nimmt mit geschwindigkeit zu
		sangle *= (velocity.getLength() / VMAX);
		// zurueck geben
		return sangle;
	}
	
	private function whileNotOnTrack():Void
	{
		// testen, ob fahrzeug auf streckenteil, das nicht befahren werden darf
		if (controller.isVehicleOffRoad()) bounceVehicle(Math.PI, true);
	}
	
//	private function updateAcceleration():Void
//	{
//		// abkuerzung
//		var kd:Function = Key.isDown;
//		
//		// beschleunigen
//		if (kd(KEYS.up)) {
//			// beschleunigungsvektor
//			var aup:Vector = onAccelerate();
//			// beschleunigungsvektor addieren
//			acceleration.addVector(aup);
//			// ggf. linearbeschleunigung deckeln
//			if (acceleration.getLength() > AMAX) acceleration.setLength(AMAX);
//		}
//		// abbrechen, wenn langsamer als mindestgeschwindigkeit
//		if (velocity.getLength() <= VMIN) return;
//		// bremsen
//		if (kd(KEYS.down)) {
//			// bremsvektor
//			var abrake:Vector = onBrake();
//			// bremsvektor addieren
//			acceleration.addVector(abrake);
//			
//			// testen, ob gerade mit bremsen begonnen
//			if (myBrakeStatus == false) {
//				// testen, ob schnell genug
//				if (velocity.getLength() > BRAKE_VMIN) {
//					// startzeitpunkt beim bremsen
//					myBrakeTimeStart = getTimer();
//					// status beim bremsen
//					myBrakeStatus = true;
//				}
//			// testen, ob bremsspur
//			} else if (getTimer() - myBrakeTimeStart > BRAKE_TIME) {
//				
//				trace("bremsspur");
//			}
//		// reibung
//		} else {
//			// reibungsvektor
//			var afriction:Vector = onFriction();
//			// reibungsvektor addieren
//			acceleration.addVector(afriction);
//		}
//	
//		// lenkrichtung
//		var dirsteer:Number;
//		// links
//		if (kd(KEYS.left)) dirsteer = STEER_LEFT;
//		// rechts
//		if (kd(KEYS.right)) dirsteer = STEER_RIGHT;
//		// geradeaus
//		if (!kd(KEYS.left) && !kd(KEYS.right) || (kd(KEYS.left) && kd(KEYS.right))) dirsteer = 0;
//		// lenkwinkel
//		var sangle:Number = getSteerAngle(dirsteer);  // 1 / 180 * Math.PI;
//		
//		var vangle:Number = Math.abs(Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180));
//		trace("acceleration / velocity: " + Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180));
//		
//		// abbrechen, wenn winkel zwischen beschleunigung und geschwindigkeit zu gross
//		if ((vangle > STEER_ANGLE_MAX && vangle < (180 - STEER_ANGLE_MAX)) || (vangle > (180 + STEER_ANGLE_MAX) && vangle < (360 - STEER_ANGLE_MAX))) return;
//		
//		// beschleunigung drehen
//		acceleration.rotateBy(sangle);
//		// reibungsvektor drehen
//		myFriction.rotateBy(sangle);
////		trace("acceleration / friction: " + Math.round((acceleration.getAngle() - myFriction.getAngle()) / Math.PI * 180));
//		// bremsvektor drehen
//		myBrake.rotateBy(sangle);
//	}
//	
//	private function onAccelerate():Vector
//	{
//		// betrag beschleunigungsvektor
//		var up:Number = (ontrack ? AUP_ON : AUP_OFF);
//		// neuer beschleunigungsvektor
//		var aup:Vector = new Vector(up, up);
//		// in richtung der geschwindigkeit ausrichten
//		aup.setAngle(acceleration.getAngle());
//		// und zurueck geben
//		return (aup);
//	}
//	
//	private function onBrake():Vector
//	{
//		// betrag bremsvektor
//		var brake:Number = ABRAKE;
//		// reibung nimmt mit geschwindigkeit zu
//		myBrake.setLength(brake * velocity.getLength() / VMAX);
//		// und zurueck geben
//		return (myBrake);
//	}
//	
//	private function onFriction():Vector
//	{
//		// betrag reibungsvektor
//		var friction:Number = (ontrack ? AFRICTION_ON : AFRICTION_OFF);
//		// reibung nimmt mit geschwindigkeit zu
//		myFriction.setLength(friction * velocity.getLength() / VMAX);
//		// und zurueck geben
//		return (myFriction);
//	}
//
//	private function updateAngles():Void
//	{
//		// winkel zwischen reibung und geschwindigkeit
//		var fangle:Number = myFriction.getAngle() - velocity.getAngle();
//		// reibungsvektor drehen
//		myFriction.rotateBy(Math.PI - fangle);
//		// bremsvektor drehen
//		myBrake.rotateBy(Math.PI - fangle);
//		// beschleunigung drehen
//		acceleration.rotateBy(Math.PI - fangle);
//	}
}