/* 
 * Generated by ASDT 
*/

/*
klasse:			VehicleUser
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		04.06.2005
zuletzt bearbeitet:	26.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleUser extends Vehicle {
	
	private static var KEYS:Object = {left : Key.LEFT, right : Key.RIGHT, up : Key.UP, brake : Key.SPACE, reverse : Key.DOWN};
	
	private static var VREVERSE:Number = VMAX / 4; // maximale geschwindigkeit beium rueckwaerts fahren
	
	private static var STEER_LEFT:Number = -1; // lenken nach links
	
	private static var STEER_RIGHT:Number = 1; // lenken nach rechts
	
	private static var STEER_ANGLE:Number = 18 / 180 * Math.PI; // lenkwinkel je update
	
	private static var STEER_TIME:Number = 1200; // lenkzeit bis erreichen lenkwinkel
	
	private static var STEER_ANGLE_MAX:Number = 80; // maximaler lenkwinkel
	
	private static var STEER_VMIN:Number = VMAX * 0.05; // mindestgeschwindigkeit, ab der lenken erlaubt
	
	private static var BRAKE_TIME:Number = 1000; // bremszeit bis auftreten bremsspuren
	
	private static var BRAKE_VMIN:Number = VMAX * 0.8; // mindestgeschwindigkeit, ab der bremsspuren
	
	private static var SLIDE_ANGLE:Number = 0.5; // mindestlenkwinkelverhaeltnis, ab dem sliden
	
	private static var SLIDE_VMIN:Number = VMAX * 0.5; // mindestgeschwindigkeit, ab der sliden
	
	private var isReverse:Boolean;
	
	private var mySteerTimeStart:Number;
	
	private var mySteerDirection:Number;
	
	private var myBrakeTimeStart:Number;
	
	private var myBrakeStatus:Boolean;
	
	private var myLap:Number;
	
	private var myLastLap:Number;
	
	private var isMovingOnRoad:Boolean;
	
	public function VehicleUser() {
		// eigenschaften des vehicle
		super.constructor.apply(super, arguments);
		// typ des vehicles
		type = TYPE_USER;
		// faehrt das fahrzeug rueckwaerts
		isReverse = false;
		// startzeitpunkt beim lenken
		mySteerTimeStart = getTimer();
		// letzte richtung beim lenken
		mySteerDirection = 0;
		// startzeitpunkt beim bremsen
		myBrakeTimeStart = getTimer();
		// status beim bremsen
		myBrakeStatus = false;
		// rennrunde
		myLap = 0;
		// vorherige rennrunde
		myLastLap = 0;
		// wird von offroad richtung road bewegt
		isMovingOnRoad = false;
	}
	
	public function initVehicle(mc:VehicleUI, point:Point, angle:Number ):Void
	{
		// methode des vehicle
		super.initVehicle.apply(super, arguments);
		// tastendruck ueberwachen
		Key.addListener(this);
	}
	
	public function resetVehicle():Void
	{
		// methode des vehicle
		super.resetVehicle.apply(super, arguments);
		// onEnterFrame loeschen
//		movieclip.resetVehicleUI();
	}
	
	public function onUpdateStroke():Void
	{
		// testen, ob fahrzeug auf strecke
		ontrack = controller.isVehicleOnTrack();
		// testen, ob fahrzeug in richtiger richtung
		indirection = controller.isVehicleInDirection();
		// checken, ob beschleunigen
		checkAccelerating();
		// checken, ob lenken
		checkSteering();
		// was passiert, wenn das fahrzeug nicht auf der strecke ist
		if (!ontrack) whileNotOnTrack();
		// geschwindigkeit updaten
		updateVelocity();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// sound updaten
		updateSound();
		// controller informieren
		RaceController.getInstance().onVehicleMove(this);
	}
	
	public function onChangeTrackpiece():Void
	{
		// testen, ob richtig rum ueber ziel gefahren
		if (controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT).id == 0 && controller.isVehicleInDirection()) {
			// neue runde
			if (myLap == myLastLap) myLap ++;
			// zaehlen lassen
			RaceController.getInstance().countLap(myLap);
		}
		// prozent der strecke zurueck gelegt
		var percent:Number = controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT).id / (RaceController.getInstance().track.getNumTrackpieces() - 1) * 100;
		// testen, ob etwa die haelfte
		if (percent > 30 && percent < 70) {
			// letzte runde hochzaehlen, damit beiueberfahren des ziels neue runde gezaehlt werden darf
			if (myLap != myLastLap) myLastLap ++;
		}
	}
	
	public function onKeyDown():Void
	{
	}
	
	public function onKeyUp():Void
	{
		// bremsen beendet
		if (Key.getCode() == KEYS.brake) {
			// status beim bremsen
			myBrakeStatus = false;
			// sound ausblenden
			mySoundBrake.stop();
		}
	}
	
	private function checkAccelerating():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// aktuelle geschwindigkeit
		var v:Number = velocity.getLength();
		// aktueller gang
		var gear:Number = getGear();
		
		// testen, ob fahrzeg gesteuert werden darf
		if (driving) {
			// beschleunigen
			if (kd(KEYS.up)) {
				// geschwindigkeit erhoehen, wenn 1. auf der strecke oder 2. ausserhalb der strecke und langsam genug
				if (ontrack || (!ontrack && v <= VMAX_OFF)) v += (ontrack ? AUP_ON : AUP_OFF) / gear;
				// testen, ob rueckwaerts
				if (isReverse) {
					// geschwindigkeit drehen
					velocity.setAngle(angle);
					// nicht mehr rueckwaerts
					isReverse = false;
				}
			// rueckwaerts
			} else if (kd(KEYS.reverse)) {
				// testen, ob vorwaerts
				if (isReverse == false) {
					// testen, ob langsam genug
					if (Math.floor(velocity.getLength() / VMIN) <= 1) {
						// geschwindigkeit drehen
						velocity.setAngle(angle + Math.PI);
						// rueckwaerts
						isReverse = true;
					}
				// rueckwaerts
				} else {
					// beschleunigen
					v += (ontrack ? AUP_ON : AUP_OFF) / gear;
					// gleichmaessige geschwindigkeit
					if (v > VREVERSE) v = VREVERSE;
				}
			}
			// bremsen
			if (kd(KEYS.brake)) {
				// testen, ob schnell genug
				if (Math.floor(velocity.getLength() / VMIN) > 1) {
					// geschwindigkeit reduzieren
					v -= ABRAKE;
					
					// testen, ob gerade mit bremsen begonnen
					if (myBrakeStatus == false) {
							// status beim bremsen
							myBrakeStatus = true;
						// testen, ob schnell genug
						if (velocity.getLength() > BRAKE_VMIN) {
							// startzeitpunkt beim bremsen
							myBrakeTimeStart = getTimer();
						}
					// testen, ob bremsspur
					} else if (getTimer() - myBrakeTimeStart > BRAKE_TIME) {
						// sound abspielen
						mySoundBrake.start(0, 10);
					}
				}
			}
		}
		// reibung
		v -= ((ontrack ? AFRICTION_ON : AFRICTION_OFF)); //  * velocity.getLength() / VMAX
		
		// testen, ob mindestgeschwindigkeit unterschritten wuerde
		if (v < VMIN) v = VMIN;
		// aenderung der geschwindigkeit
		if (v < velocity.getLength()) {
			velocitydir = -1;
		} else if (v > velocity.getLength()) {
			velocitydir = 1;
		} else {
			velocitydir = 0;
		}
		// neue geschwindigkeit setzen
		velocity.setLength(v);
	}
	
	private function checkSteering():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// lenkwinkel
		var sangle:Number;
		// lenkrichtung
		var dirsteer:Number;
		// links
		if (kd(KEYS.left)) {
			dirsteer = STEER_LEFT;
		// rechts
		} else if (kd(KEYS.right)) {
			dirsteer = STEER_RIGHT;
		// geradeaus
		} else {
			dirsteer = 0;
		}
		// lenkwinkel ermitteln
		sangle = getSteerAngle(dirsteer);
		// testen, ob rueckwaerts
		if (isReverse) sangle *= -1;
		// geschwindigkeit drehen
		velocity.rotateBy(sangle);
		// drehwinkel drehen
		angle += sangle;
		// testen, ob zu gross oder klein
		if (angle > 2 * Math.PI) angle -= 2 * Math.PI;
		if (angle < -2 * Math.PI) angle += 2 * Math.PI;
		
		
//		// sliden ?
//		if (Math.abs(sangle / STEER_ANGLE) > SLIDE_ANGLE) { // dirsteer != 0
//			myAngleSlide = (velocity.getLength() / VMAX) * (sangle / STEER_ANGLE) * 0.5;
//		} else {
//			myAngleSlide *= 0.6;
//		}
	}
	
	private function getSteerAngle(direction:Number ):Number
	{
		// abbrechen, wenn zu langsam
		if (velocity.getLength() < STEER_VMIN) return 0;
		// testen, ob richtung gewechselt
		if (direction != mySteerDirection) {
			// letzte richtung beim lenken
			mySteerDirection = direction;
			// startzeitpunkt beim lenken
			mySteerTimeStart = getTimer();
		}
		// dauer des lenkens
		var time:Number = getTimer() - mySteerTimeStart;
		// lenkwinkel (betrag)
		var sangle:Number = time / STEER_TIME * STEER_ANGLE;
		// deckeln
		if (sangle > STEER_ANGLE) sangle = STEER_ANGLE;
		// links / rechts
		sangle *= direction;
		// lenkung nimmt mit geschwindigkeit zu
		sangle *= (velocity.getLength() / VMAX);
		// zurueck geben
		return sangle;
	}
	
	private function whileNotOnTrack():Void
	{
		// testen, ob fahrzeug auf streckenteil, das nicht befahren werden darf
		offroad = controller.isVehicleOffRoad();
		// fahrzeug zurueck bouncen
//		if (offroad) bounceVehicle(Math.PI, true);
		if (offroad && !isMovingOnRoad) {
			// sound
			var snd:Sound = new Sound(movieclip.shadow_mc);
			snd.attachSound("bounce");
			snd.start();
			// vector entgegengesetzt der geschwindigkeit
			var dir:Vector = new Vector(velocity.xdiff, velocity.ydiff);
			dir.rotateBy(Math.PI);
			dir.multiplyBy(2);
			// zurueck bewegen
			moveOnRoad(dir);
		}
	}
	
	private function moveOnRoad(dir:Vector ):Void
	{
		// abbremsen (10.08.: nicht auf VMIN, da schleife sonst endlos wg. zu langsam)
		velocity.setLength(VMIN); // 
		// bewegen
		position.movePoint(dir);
//		// position so lange aendern, bis nicht mehr offroad
//		for (var i : Number = 0; i < 10; i++) {
//			// bewegen
//			position.movePoint(dir);
//			// wird von offroad richtung road bewegt
//			isMovingOnRoad = true;
//			// abbrechen, wenn nicht mehr offroad
//			if (!controller.isVehicleOffRoad()) break;
//		}
		
		
		
//		do {
//			// bewegen
//			position.movePoint(dir);
//			// wird von offroad richtung road bewegt
//			isMovingOnRoad = true;
//		} while (controller.isVehicleOffRoad());
		// wird nicht mehr von offroad richtung road bewegt
		isMovingOnRoad = false;
	}
}