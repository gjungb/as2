/* 
 * Generated by ASDT 
*/ 

/*
klasse:			Vehicle
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	26.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.Vehicle implements Strokable {
	
	public static var TYPE_USER:Number = 1;
	
	public static var TYPE_COMPUTER:Number = 2;
	
	private static var ATTENUATION:Number = 25;
	
	public static var GEARS:Number = 6; // anzahl gaenge
	
	private static var VMIN:Number = 1e-2; // minimale lineargeschwindigkeit
	
	public static var VMAX:Number = 60; // 40; // maximale lineargeschwindigkeit auf der strecke
	
	private static var VMAX_OFF:Number = VMAX / 6; // maximale lineargeschwindigkeit ausserhalb der strecke
	
	private static var AMIN:Number = 1e-6 / ATTENUATION; // minimale linearbeschleunigung
	
	private static var AMAX:Number = 8 / ATTENUATION; // maximale linearbeschleunigung
	
	private static var AMAX_OFF:Number = 0.01; // maximale linearbeschleunigung ausserhalb der strecke
	
	private static var AUP_ON:Number = 20 / ATTENUATION * GEARS; // betrag beschleunigungsvektor beim gas geben auf strecke
	
	private static var AUP_OFF:Number = 22 / ATTENUATION * GEARS; // 14; // betrag beschleunigungsvektor beim gas geben neben strecke
	
	private static var ABRAKE:Number = 24 / ATTENUATION; // 14; // betrag beschleunigungsvektor beim bremsen
	
	private static var AFRICTION_ON:Number = 12 / ATTENUATION; // betrag beschleunigungsvektor bei reibung auf strecke
	
	private static var AFRICTION_OFF:Number = 20 / ATTENUATION; // 12; // betrag beschleunigungsvektor bei reibung neben strecke
	
	private var myInterval:Number;
	
	private var myType:Number;
	
	private var myId:Number;
	
	private var myController:VehicleController;
	
	private var myMovieclip:VehicleUI;
	
	private var myPosition:Point;
	
	private var myVelocity:Vector;
	
	private var myLastLinearVelocity:Number;
	
	private var myVelocityDir:Number;
	
	private var myAcceleration:Vector;
	
	private var myAngle:Number;
	
	private var myAngleSlide:Number;
	
	private var isDriving:Boolean;
	
	private var isOnTrack:Boolean;
	
	private var isOffRoad:Boolean;
	
	private var isInDirection:Boolean;
	
	private var mySoundVelocity:VehicleSoundPitch;
	
	private var mySoundBrake:Sound;
	
	private var myStroke:StrokeUI;
	
	public function Vehicle(id:Number )
	{
		// typ des vehicles
		type = null;
		// eindeutige id
		myId = id;
		// controller, ob fahrzeug auf strecke
		myController = new VehicleController(this);
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = null;
		// aktuelle position
		myPosition = new Point(0, 0);
		// aktuelle geschwindigkeit
		myVelocity = new Vector(1, 1);
		// auf minimalgeschwindigkeit (wg. rundungsfehler / 2, sonst 1.0000001)
		myVelocity.setLength(VMIN / 2);
		// lineargeschwindigkeit, mit der das fahrzeug zuletzt gefahren ist
		myLastLinearVelocity = 0;
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		myVelocityDir = 0;
		// aktuelle beschleunigung
		myAcceleration = new Vector(1, 1);
		// auf minimalbeschleunigung
		myAcceleration.setLength(AMIN);
		// drehwinkel
		myAngle = 0;
		// zusaetzlicher winkel beim sliden
		myAngleSlide = 0;
		// darf das fahrzeug fahren
		isDriving = false;
		// befindet sich das fahrzeug auf der rennstrecke
		isOnTrack = true;
		// befindet sich das fahrzeug auf streckenteil, das nicht befahren werden darf
		isOffRoad = false;
		// faehrt das fahrzeug in die richtige richtung
		isInDirection = true;
		// taktgeber
		myStroke = _global.Stroke;
	}
	
	public function initVehicle(mc:VehicleUI, point:Point, angle:Number ):Void
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = mc;
		// positionieren
		setPosition(point.x, point.y);
		// geschwindigkeit drehen
		velocity.setAngle(angle);
		// beschleunigung drehen
		acceleration.setAngle(angle);
		// drehwinkel
		myAngle = angle;
		// movieclip updaten
		updateMovieclip();
		// testen, ob auf strecke; controller initialisieren
		controller.isVehicleOnTrack();
		
		// sound fuer geschwindigkeit initialisieren
		mySoundVelocity = new VehicleSoundPitch(this, "engine_up", "engine_down");
		// sound fuer bremsen initialisieren
		mySoundBrake = new Sound(mc.color_mc);
		mySoundBrake.attachSound("brake");
	}
	
	public function resetVehicle():Void
	{
		// sound stoppen
		mySoundVelocity.stop();
		// sound loeschen
		delete(mySoundVelocity);
	}
	
	public function set type(tnum:Number ):Void
	{
		// typ des vehicles
		myType = tnum;
	}
	
	public function get type():Number
	{
		// typ des vehicles
		return myType;
	}
	
	public function get id():Number
	{
		// eindeutige id
		return myId;
	}
	
	public function get controller():VehicleController
	{
		// controller, ob fahrzeug auf strecke
		return myController;
	}
	
	public function get movieclip():VehicleUI
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		return myMovieclip;
	}

	public function get position():Point
	{
		// aktuelle position
		return myPosition;
	}

	public function get velocity():Vector
	{
		// aktuelle geschwindigkeit
		return myVelocity;
	}
	
	public function set velocitydir(vnum:Number ):Void
	{
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		myVelocityDir = vnum;
	}
	
	public function get velocitydir():Number
	{
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		return myVelocityDir;
	}

	public function set acceleration(aobj:Vector ):Void
	{
		// aktuelle beschleunigung
		myAcceleration = aobj;
	}

	public function get acceleration():Vector
	{
		// aktuelle beschleunigung
		return myAcceleration;
	}
	
	public function set angle(anum:Number ):Void
	{
		// drehwinkel
		myAngle = anum;
	}
	
	public function get angle():Number
	{
		// drehwinkel
		return myAngle;
	}

	public function set driving(bool:Boolean ):Void
	{
		// darf das fahrzeug fahren
		isDriving = bool;
	}

	public function get driving():Boolean
	{
		// darf das fahrzeug fahren
		return isDriving;
	}

	public function set ontrack(bool:Boolean ):Void
	{
		// befindet sich das fahrzeug auf der rennstrecke
		isOnTrack = bool;
	}

	public function get ontrack():Boolean
	{
		// befindet sich das fahrzeug auf der rennstrecke
		return isOnTrack;
	}

	public function set offroad(bool:Boolean ):Void
	{
		// befindet sich das fahrzeug auf streckenteil, das nicht befahren werden darf
		isOffRoad = bool;
	}

	public function get offroad():Boolean
	{
		// befindet sich das fahrzeug auf streckenteil, das nicht befahren werden darf
		return isOffRoad;
	}

	public function set indirection(bool:Boolean ):Void
	{
		// faehrt das fahrzeug in die richtige richtung
		isInDirection = bool;
	}

	public function get indirection():Boolean
	{
		// faehrt das fahrzeug in die richtige richtung
		return isInDirection;
	}
	
	public function onUpdateStroke():Void {}

	public function registerMovieclip(mc:VehicleUI ):Void
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = mc;
	}

	public function unregisterMovieclip():Void
	{
		// referenz loeschen
		myMovieclip = null;
	}
	
	public function startVehicle():Void
	{
		// beim taktgeber anmelden
//		myStroke.addListener(this);
	}
	
	public function stopVehicle():Void
	{
		// beim taktgeber abmelden
//		myStroke.removeListener(this);
	}
	
	public function setPosition(xpos:Number, ypos:Number ):Void
	{
		// positionieren
		position.x = xpos;
		position.y = ypos;
	}
	
	public function setVelocity(xdiff:Number, ydiff:Number ):Void
	{
		// kleine werte abfangen
		if (Math.abs(xdiff) <= 0.01) xdiff = 1 / Number.MAX_VALUE;
		if (Math.abs(ydiff) <= 0.01) ydiff = 1 / Number.MAX_VALUE;
		// neue geschwindigkeit speichern
		velocity.setDiff(xdiff, ydiff);
	}
	
	public function getGear():Number
	{
		// gesuchter gang
		var gear:Number = 0;
		// unterscheiden zwischen beschleunigen und verlangsamen
		if (velocitydir >= 0) {
			// abschnitt bei aktueller geschwindigkeit
			var currentunit:Number = getCurrentVelocityUnit();
			// es gilt: currentunit = gear * (gear + 1) / 2
			// umformung | *2, -2*currentunit
			// => 0 = gear^2 + gear - 2*currentunit
			// es sei: gear = x, -2*currentunit = a0
			// quadratische gleichung a2x^2 + a1x + a0 = 0
			// es sei: a2 = 1, a1 = 1, a0 = -2*currentunit
			// umformung | a2
			// => normalform: x^2 + px + q = 0 
			// mit p = a1 / a2 (=1) und q = a0 / a2 (=-2*currentunit)
			// loesung: x1,2 = -p/2 +- sqr((p/2)^2 - q)
			var p:Number = 1;
			var q:Number = -2*currentunit;
			var x1:Number = -p/2 + Math.sqrt((p/2)*(p/2) - q);
			var x2:Number = -p/2 - Math.sqrt((p/2)*(p/2) - q);
			// gesuchter gang
			gear = Math.ceil(x1);
		} else {
			// linear runter schalten
			gear = Math.floor(velocity.getLength() / (VMAX / GEARS));
		}
		// minimum
		if (gear == 0) gear = 1;
		// deckeln
		if (gear > GEARS) gear = GEARS;
		// zurueck geben
		return gear;
	}
	
	public function getRelativeRPM():Number
	{
		// gesuchte relative drehzahl (zwischen 0 und 1)
		var rpm:Number;
		// aktueller gang
		var gear:Number = getGear();
		// unterscheiden zwischen beschleunigen und verlangsamen
		if (velocitydir >= 0) {
			// abschnitt bei aktueller geschwindigkeit
			var currentunit:Number = getCurrentVelocityUnit();
			// abschnitt am anfang des gangs
			var unitmin:Number = (gear - 1) * gear / 2;
			// abschnitt am ende des gangs
			var unitmax:Number = gear * (gear + 1) / 2;
			// gesuchte relative drehzahl (zwischen 0 und 1)
			rpm = (currentunit - unitmin) / (unitmax - unitmin);
		} else {
			// geschwindigkeit am anfang des gangs
			var vmin:Number = gear * (VMAX / GEARS);
			// geschwindigkeit am ende des gangs
			var vmax:Number = (gear + 1) * (VMAX / GEARS);
			// gesuchte relative drehzahl (zwischen 0 und 1)
			rpm = (velocity.getLength() - vmin) / (vmax - vmin);
			// negative werte abfangen
			if (rpm < 0) rpm = 0;
		}
		// zurueck geben
		return rpm;
	}
	
	public function onChangeTrackpiece():Void {}
	
	private function updateVelocity():Void
	{
		// neue geschwindigkeit
		velocity.addVector(acceleration);
		// ggf. geschwindigkeit deckeln
		if (velocity.getLength() > VMAX) velocity.setLength(VMAX);
		// ggf. minimalgeschwindigkeit
		if (velocity.getLength() < VMIN) {
			// minimalgeschwindigkeit (wg. rundungsfehler / 2, sonst 1.0000001)
			velocity.setLength(VMIN / 2);
			// beschleunigung in richtung geschwindigkeit
			acceleration.setAngle(velocity.getAngle());
		}
	}
	
	private function updatePosition():Void
	{
		// neue position
		position.movePoint(velocity);
	}
	
	private function updateMovieclip():Void
	{
		// movieclip positionieren
		movieclip.setPosition(position);
		// movieclip drehen
		movieclip.setRotation((angle + myAngleSlide) / Math.PI * 180);
	}
	
	private function getCurrentVelocityUnit():Number
	{
		// kleinster abschnitt auf geschwindigkeitsachse
		var vunit:Number = VMAX / (GEARS * (GEARS + 1) / 2);
		// abschnitt bei aktueller geschwindigkeit
		var currentunit:Number = velocity.getLength() / vunit;
		// zurueck geben
		return currentunit;
	}
	
	private function updateSound():Void
	{
		// sound updaten
		mySoundVelocity.setOffset(velocity.getLength() / VMAX);
		// einblenden
		mySoundVelocity.setVolume(100);
	}
	
	private function bounceVehicle(angle:Number, repeat:Boolean ):Void
	{
		// geschwindigkeit drehen
		velocity.rotateBy(angle);
		// erstes oder zweites mal
		if (repeat) {
			// sound
			var snd:Sound = new Sound(movieclip);
			snd.attachSound("bounce");
			snd.start();
			velocity.multiplyBy(1.5);
			// nach pause wieder drehen
			myInterval = setInterval(this, "bounceVehicle", 200, angle, false);
		} else {
			// abbremsen
			velocity.setLength(VMIN);
			// nur einmal
			clearInterval(myInterval);
		}
	}
	
	private function updateAcceleration():Void {}
	
	private function whileNotOnTrack():Void {}

}