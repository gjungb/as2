/* 
 * Generated by ASDT 
*/ 

/*
klasse:			VehicleComputer
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		21.05.2005
zuletzt bearbeitet:	28.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleComputer extends Vehicle {
	
	public static var STRENGTH_FAST:Number = 1;
	
	public static var STRENGTH_MEDIUM:Number = 2;
	
	public static var STRENGTH_SLOW:Number = 3;
	
	private static var ATT_MIN:Number = 1.6; // je groesser desto langsamer die autos
	
	private static var ATT_FACTOR:Number = 0.6; // je groesser desto unterschiedlicher die autos
	
	private var myStrength:Number;
	
	private var myTargetPosition:Point;
	
	private var myDirection:Vector;
	
	private var myTrackDirection:Number;
	
	public function VehicleComputer()
	{
		// eigenschaften des vehicle
		super.constructor.apply(super, arguments);
		// typ des vehicles
		type = TYPE_COMPUTER;
		// staerke
		myStrength = STRENGTH_MEDIUM;
		// zielposition
		myTargetPosition = new Point(0, 0);
		// aktuelle fahrtrichtung
		myDirection = new Vector(0, 0);
		// richtung der strecke (-1 || 0 || 1)
		myTrackDirection = Track.DIRECTION_STRAIGHT;
	}
	
	public function set strength(num:Number ):Void
	{
		// staerke
		myStrength = num;
	}
	
	public function get strength():Number
	{
		// staerke
		return myStrength;
	}
	
	public function get targetposition():Point
	{
		// zielposition
		return myTargetPosition;
	}
	
	public function get direction():Vector
	{
		// aktuelle fahrtrichtung
		return myDirection;
	}
	
	public function set trackdirection(num:Number ):Void
	{
		// richtung der strecke (-1 || 0 || 1)
		myTrackDirection = num;
	}
	
	public function get trackdirection():Number
	{
		// richtung der strecke (-1 || 0 || 1)
		return myTrackDirection;
	}
	
	public function onUpdateStroke():Void
	{
		// testen, ob fahrzeug auf strecke
		ontrack = controller.isVehicleOnTrack();
		// testen, ob fahrzeug in richtiger richtung
		indirection = controller.isVehicleInDirection();
		// checken, ob beschleunigen
		if (driving) checkAccelerating();
		// checken, ob lenken
		if (driving) checkSteering();
		// was passiert, wenn das fahrzeug nicht auf der strecke ist
		if (!ontrack) whileNotOnTrack();
		// geschwindigkeit updaten
//		updateVelocity();
		// drehwinkel anpassen
		angle = velocity.getAngle();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// sound updaten
//		updateSound();
		// controller informieren
		RaceController.getInstance().onVehicleMove(this);
	}
	
	public function onChangeTrackpiece():Void
	{
		// zielposition auf naechstes streckenteil
		updateTargetPosition(VehicleController.TRACKPIECE_NEXT);
		// aktuelles streckenteil
		var trackpiece:TrackPiece = controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT);
		// anzahl streckenteile fuer vorschau
		var numpieces:Number = 4;
		// vorhersage ueber richtung der strecke
		trackdirection = RaceController.getInstance().track.getDirectionPrediction(trackpiece, numpieces);
	}
	
	private function checkAccelerating():Void
	{
		// aktuelle geschwindigkeit
		var v:Number = velocity.getLength();
		// aktueller gang
		var gear:Number = getGear();
		
		// abschwaechung der geschwindigkeit je nach staerke
		var att:Number = ATT_MIN + ATT_FACTOR * (strength - 1);
		// beschleunigen
		if (trackdirection == Track.DIRECTION_STRAIGHT || velocity.getLength() < (VMAX / att)) {
			// geschwindigkeit erhoehen, wenn 1. auf der strecke oder 2. ausserhalb der strecke und langsam genug
			if (ontrack || (!ontrack && v <= VMAX_OFF)) v += (ontrack ? AUP_ON : AUP_OFF) / att / gear;
		// vor kurven bremsen
		} else {
			// testen, ob schnell genug
			if (Math.floor(velocity.getLength() / VMIN) > 1) {
				// geschwindigkeit reduzieren
				v -= ABRAKE * att;
			}
		}
		// reibung
		v -= (ontrack ? AFRICTION_ON : AFRICTION_OFF) / att;
		
		// testen, ob mindestgeschwindigkeit unterschritten wuerde
		if (v < VMIN) v = VMIN;
		// aenderung der geschwindigkeit
		if (v < velocity.getLength()) {
			velocitydir = -1;
		} else if (v > velocity.getLength()) {
			velocitydir = 1;
		} else {
			velocitydir = 0;
		}
		// neue geschwindigkeit setzen
		velocity.setLength(v);
	}
	
	private function checkSteering():Void
	{
		// aktuelle geschwindigkeit
		var v:Number = velocity.getLength();
		// zufallsabweichung von "ideallinie"
		var rand:Number = (0.6 + Math.random() * 0.8)
		// x-abstand zur zielposition
		var xdiff:Number = (targetposition.x - position.x) * rand;
		// y-abstand zur zielposition
		var ydiff:Number = (targetposition.y - position.y) * rand;
		// fahrtrichtung aktualisieren
		direction.setDiff(xdiff, ydiff);
		// beschleunigen
		acceleration.setLength(15);
		// beschleunigung drehen
		acceleration.setAngle(direction.getAngle());
		// geschwindigkeit um beschleunigung aendern => drehen
		updateVelocity();
		// wieder auf vorherigen geschwindigkeitsbetrag (damit checkAccelerating bestimmt, wie schnell gefahren wird)
		velocity.setLength(v);
//		// winkel zwischen geschwindigkeit und verbindungsvektor
//		var sangle:Number = direction.getAngle() - velocity.getAngle();
//		// geschwindigkeit drehen
//		velocity.setAngle(direction.getAngle());
		// drehwinkel anpassen
		angle = velocity.getAngle();
//		// daempfen
//		sangle /= 2;
//		// geschwindigkeit drehen
//		velocity.rotateBy(sangle);
//		// drehwinkel drehen
//		angle += sangle;
		// testen, ob zu gross oder klein
		if (angle > 2 * Math.PI) angle -= 2 * Math.PI;
		if (angle < -2 * Math.PI) angle += 2 * Math.PI;
	}
	
	private function updateTargetPosition(type:Number ):Void
	{
		// streckenteil, in dessen richtung das fahrzeug fahren soll
		var trackpiece:TrackPiece = controller.getTrackpiece(type);
		// schwerpunkt
		var center:Point = trackpiece.polygon.center;
		// zielposition updaten
		targetposition.x = center.x;
		targetposition.y = center.y;
	}
	
//	private function updateAcceleration():Void
//	{
//		// zufallsabweichung von "ideallinie"
//		var rand:Number = (0.8 + Math.random() * 0.4)
//		// x-abstand zur zielposition
//		var xdiff:Number = (targetposition.x - position.x) * rand;
//		// y-abstand zur zielposition
//		var ydiff:Number = (targetposition.y - position.y) * rand;
//		// fahrtrichtung aktualisieren
//		direction.setDiff(xdiff, ydiff);
//		// winkel der aktuellen fahrtrichtung
//		var angle:Number = direction.getAngle();
//		// testen, ob fast erreicht
//		if (direction.getLength() < 50) {
//			// zielposition auf naechstes streckenteil
//			updateTargetPosition(VehicleController.TRACKPIECE_NEXT);
//		}
//		// beschleunigen
//		acceleration.setLength(5);
//		// beschleunigung drehen
//		acceleration.setAngle(angle);
//	}
}