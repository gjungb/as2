/* 
 * Generated by ASDT 
*/ 

/*
klasse:			TrackUI
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	07.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.graph.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

class com.adgamewonderland.agw.racing.track.TrackUI extends MovieClip implements Strokable {
	
	private static var SCALE:Number = 1 / 2;
	
	private static var DIMENSIONS:Object = {x : 0, y : 0, width : 640, height : 480};
	
	private static var BORDER:Object = {x : 600, y : 400};

	private static var CENTER_ATTENUATION:Number = 4;
	
	private var myBoxOuter:Polygon;
	
	private var myBoxInner:Polygon;
	
	private var myCenter:Point;
	
	private var myTargetPosition:Point;
	
	private var myTargetVector:Vector;
	
	private var myStroke:StrokeUI;
	
	private var trackpic_mc:MovieClip;
	
	public function TrackUI()
	{
		// beim racecontroller anmelden
		RaceController.getInstance().trackui = this;
		// umrandende box
		myBoxOuter = new Polygon();
		// innere box
		myBoxInner = new Polygon;
		// skalieren und dimensionen anpassen
		zoomTo(SCALE);
		
		// umrandende box initialisieren
		initBoxOuter();
		// mittelpunkt der umrandenden box
		myCenter = myBoxOuter.center; // new Point(DIMENSIONS.x + DIMENSIONS.width /2, DIMENSIONS.y + DIMENSIONS.height /2);
		// zielpunkt, zu dem die streckenanzeige beim zentrieren bewegt werden soll
		myTargetPosition = new Point(0, 0);
		// vektor zwischen mittelpunkt und zielpunkt
		myTargetVector = new Vector(0, 0);
		// taktgeber
		myStroke = _global.Stroke;
	}
	
	public function initBoxInner(width:Number, height:Number ):Void
	{
		// breite der box
		var xdiff:Number = width - BORDER.x * 2;
		// hoehe der box
		var ydiff:Number = height - BORDER.y * 2;
		// vier punkte hinzufuegen
		myBoxInner.addPoint(new Point(BORDER.x, BORDER.y));
		myBoxInner.addPoint(new Point(BORDER.x + xdiff, BORDER.y));
		myBoxInner.addPoint(new Point(BORDER.x + xdiff, BORDER.y + ydiff));
		myBoxInner.addPoint(new Point(BORDER.x, BORDER.y + ydiff));
//		// malbrett
//		var db:DrawingBoard = new DrawingBoard(this);
//		// auf buehne anzeigen
//		db.drawPolygon(myBoxInner, false);
	}
	
	public function startTrack():Void
	{
		// beim taktgeber anmelden
		myStroke.addListener(this);
	}
	
	public function stopTrack():Void
	{
		// beim taktgeber abmelden
		myStroke.removeListener(this);
	}
	
	public function zoomTo(scale:Number ):Void
	{
		// skalieren
		_xscale = _yscale = scale * 100;
		// streckenbild invers skalieren
		trackpic_mc._xscale = trackpic_mc._yscale = 1 / scale * 100;
		// dimensionen anpassen
		DIMENSIONS.width *= 1 / scale;
		DIMENSIONS.height *= 1 / scale;
	}
	
	public function centerTo(point:Point ):Void
	{
		// x-position zielpunkt
		myTargetPosition.x = point.x;
		// y-position zielpunkt
		myTargetPosition.y = point.y;
	}
	
	public function onUpdateStroke():Void
	{
		// x-abstand zielpunkt
		var xdiff:Number = (myCenter.x - myTargetPosition.x) * _xscale / 100 - _x;
		// y-abstand zielpunkt
		var ydiff:Number = (myCenter.y - myTargetPosition.y) * _yscale / 100 - _y;
		// vektor zwischen mittelpunkt und zielpunkt aktualisieren
		myTargetVector.setDiff(xdiff, ydiff);
		// testen, ob zielpunkt ausserhalb der inneren box
		if (isPointInBoxInner(myTargetPosition) == false) {
			// algebra
			var algebra:LinearAlgebra = LinearAlgebra.getInstance();
			// links bedeutet ausserhalb
			var outside:Number = LinearAlgebra.POINT_LINE_RELATION_LEFT;
			// oben oder unten raus
			if (algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[0]) == outside || algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[2]) == outside) {
				// keine bewegung in y-richtung
				myTargetVector.setDiff(myTargetVector.xdiff, 0);
			}
			// rechts oder links raus
			if (algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[1]) == outside || algebra.getPointBorderRelation(myTargetPosition, myBoxInner.borders[3]) == outside) {
				// keine bewegung in x-richtung
				myTargetVector.setDiff(0, myTargetVector.ydiff);
			}
		}
		// gedaempft positionieren
		_x += myTargetVector.xdiff / CENTER_ATTENUATION;
		_y += myTargetVector.ydiff / CENTER_ATTENUATION;
	}
	
	public function showVehicle(identifier:String ):MovieClip
	{
		// tiefe
		var depth:Number = getNextHighestDepth();
		// auf buehne
		var mc:MovieClip = attachMovie(identifier, depth.toString(), depth);
		// zurueck geben
		return mc;
	}
	
	public function showTrack(track:Track ):Void
	{
		// schleife ueber alle streckenteile, die befahren werden duerfen
		for (var i:Number = 0; i < track.getNumTrackpieces(); i++) {
			// aktuelles streckenteil
			var trackpiece:TrackPiece = track.getTrackpieceById(i);
			// zeichnen
			drawTrackpiece(trackpiece);
		}
//		// schleife ueber alle streckenteile, die nicht befahren werden duerfen
//		for (var j:Number = 0; j < track.offroad.length; j++) {
//			// aktuelles streckenteil
//			var trackpiece:TrackPiece = track.offroad[j];
//			// zeichnen
//			drawTrackpiece(trackpiece);
//		}
	}
	
	private function drawTrackpiece(tobj:TrackPiece ):Void
	{
		// malbrett
		var db:DrawingBoard = new DrawingBoard(this);
		// polygon
		var polygon:Polygon = tobj.polygon;
		// auf buehne anzeigen
		db.drawPolygon(polygon, true);
	}
	
	private function initBoxOuter():Void
	{
		// vier punkte hinzufuegen
		myBoxOuter.addPoint(new Point(DIMENSIONS.x, DIMENSIONS.y));
		myBoxOuter.addPoint(new Point(DIMENSIONS.x + DIMENSIONS.width, DIMENSIONS.y));
		myBoxOuter.addPoint(new Point(DIMENSIONS.x + DIMENSIONS.width, DIMENSIONS.y + DIMENSIONS.height));
		myBoxOuter.addPoint(new Point(DIMENSIONS.x, DIMENSIONS.y + DIMENSIONS.height));
		// malbrett
		var db:DrawingBoard = new DrawingBoard(_root);
		// auf buehne anzeigen
//		db.drawPolygon(myBoxOuter, false);
	}
	
	private function isPointInBoxInner(point:Point ):Boolean
	{
		// testen
		var result:Boolean = LinearAlgebra.getInstance().isPointInPolygon(point, myBoxInner);
		// zurueck geben
		return result;
	}
}