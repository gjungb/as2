/* 
 * Generated by ASDT 
*/ 

/*
klasse:			Vehicle
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	06.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.Vehicle implements Strokable {
	
	public static var TYPE_USER:Number = 1;
	
	public static var TYPE_COMPUTER:Number = 2;
	
	private static var ATTENUATION:Number = 25;
	
	private static var VMIN:Number = 1e-2; // minimale lineargeschwindigkeit
	
	public static var VMAX:Number = 40; // 20; // maximale lineargeschwindigkeit auf der strecke
	
	private static var VMAX_OFF:Number = VMAX / 5; // maximale lineargeschwindigkeit ausserhalb der strecke
	
	private static var VFRICTION_ON:Number = 0.95; // 97; // reibungsverlust auf der strecke
	
	private static var VFRICTION_OFF:Number = 0.90; // reibungsverlust ausserhalb der strecke
	
	private static var AMIN:Number = 1e-6; // minimale linearbeschleunigung
	
	public static var AMAX:Number = 1; // maximale linearbeschleunigung auf der strecke
	
	private static var AMAX_OFF:Number = 0.01; // maximale linearbeschleunigung ausserhalb der strecke
	
	public static var GEARS:Number = 6; // anzahl gaenge
	
	private var myInterval:Number;
	
	private var myType:Number;
	
	private var myId:Number;
	
	private var myController:VehicleController;
	
	private var myMovieclip:VehicleUI;
	
	private var myPosition:Point;
	
	private var myVelocity:Vector;
	
	private var myLastLinearVelocity:Number;
	
	private var myVelocityDir:Number;
	
	private var myAcceleration:Vector;
	
	private var myAngle:Number;
	
	private var myAngleSlide:Number;
	
	private var isOnTrack:Boolean;
	
	private var mySoundVelocity:VehicleSoundPitch;
	
	private var mySoundBrake:Sound;
	
	private var myStroke:StrokeUI;
	
	public function Vehicle(id:Number )
	{
		// typ des vehicles
		type = null;
		// eindeutige id
		myId = id;
		// controller, ob fahrzeug auf strecke
		myController = new VehicleController(this);
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = null;
		// aktuelle position
		myPosition = new Point(0, 0);
		// aktuelle geschwindigkeit
		myVelocity = new Vector(1, 1);
		// auf minimalgeschwindigkeit (wg. rundungsfehler / 2, sonst 1.0000001)
		myVelocity.setLength(VMIN / 2);
		// lineargeschwindigkeit, mit der das fahrzeug zuletzt gefahren ist
		myLastLinearVelocity = 0;
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		myVelocityDir = 0;
		// aktuelle beschleunigung
		myAcceleration = new Vector(1, 1);
		// auf minimalbeschleunigung
		myAcceleration.setLength(AMIN);
		// drehwinkel
		myAngle = 0;
		// zusaetzlicher winkel beim sliden
		myAngleSlide = 0;
		// befindet sich das fahrzeug auf der rennstrecke
		isOnTrack = false;
		// taktgeber
		myStroke = _global.Stroke;
	}
	
	public function initVehicle(mc:VehicleUI, point:Point, angle:Number ):Void
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = mc;
		// positionieren
		setPosition(point.x, point.y);
		// geschwindigkeit drehen
		velocity.setAngle(angle);
		// beschleunigung drehen
		acceleration.setAngle(angle);
		// drehwinkel
		myAngle = angle;
		// movieclip updaten
		updateMovieclip();
		// testen, ob auf strecke; controller initialisieren
		controller.isVehicleOnTrack();
		
		// sound fuer geschwindigkeit initialisieren
		mySoundVelocity = new VehicleSoundPitch(this, "engine_up", "engine_down");
		// sound fuer bremsen initialisieren
		mySoundBrake = new Sound(mc);
		mySoundBrake.attachSound("brake");
	}
	
	public function set type(tnum:Number ):Void
	{
		// typ des vehicles
		myType = tnum;
	}
	
	public function get type():Number
	{
		// typ des vehicles
		return myType;
	}
	
	public function get id():Number
	{
		// eindeutige id
		return myId;
	}
	
	public function get controller():VehicleController
	{
		// controller, ob fahrzeug auf strecke
		return myController;
	}
	
	public function get movieclip():VehicleUI
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		return myMovieclip;
	}

	public function get position():Point
	{
		// aktuelle position
		return myPosition;
	}

	public function get velocity():Vector
	{
		// aktuelle geschwindigkeit
		return myVelocity;
	}
	
	public function set lastlinearvelocity(lnum:Number ):Void
	{
		// lineargeschwindigkeit, mit der das fahrzeug zuletzt gefahren ist
		myLastLinearVelocity = lnum;
	}
	
	public function get lastlinearvelocity():Number
	{
		// lineargeschwindigkeit, mit der das fahrzeug zuletzt gefahren ist
		return myLastLinearVelocity;
	}
	
	public function set velocitydir(vnum:Number ):Void
	{
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		myVelocityDir = vnum;
	}
	
	public function get velocitydir():Number
	{
		// aenderung der lineargeschwindigkeit (-1 | 0 | 1)
		return myVelocityDir;
	}

	public function set acceleration(aobj:Vector ):Void
	{
		// aktuelle beschleunigung
		myAcceleration = aobj;
	}

	public function get acceleration():Vector
	{
		// aktuelle beschleunigung
		return myAcceleration;
	}
	
	public function set angle(anum:Number ):Void
	{
		// drehwinkel
		myAngle = anum;
	}
	
	public function get angle():Number
	{
		// drehwinkel
		return myAngle;
	}

	public function set ontrack(bool:Boolean ):Void
	{
		// befindet sich das fahrzeug auf der rennstrecke
		isOnTrack = bool;
	}

	public function get ontrack():Boolean
	{
		// befindet sich das fahrzeug auf der rennstrecke
		return isOnTrack;
	}
	
	public function onUpdateStroke():Void {}

	public function registerMovieclip(mc:VehicleUI ):Void
	{
		// movieclip, das das vehicle auf der buehne anzeigt
		myMovieclip = mc;
	}

	public function unregisterMovieclip():Void
	{
		// referenz loeschen
		myMovieclip = null;
	}
	
	public function startVehicle():Void
	{
		// beim taktgeber anmelden
		myStroke.addListener(this);
	}
	
	public function stopVehicle():Void
	{
		// beim taktgeber abmelden
		myStroke.removeListener(this);
	}
	
	public function setPosition(xpos:Number, ypos:Number ):Void
	{
		// positionieren
		position.x = xpos;
		position.y = ypos;
	}
	
	public function setVelocity(xdiff:Number, ydiff:Number ):Void
	{
		// kleine werte abfangen
		if (Math.abs(xdiff) <= 0.01) xdiff = 1 / Number.MAX_VALUE;
		if (Math.abs(ydiff) <= 0.01) ydiff = 1 / Number.MAX_VALUE;
		// neue geschwindigkeit speichern
		velocity.setDiff(xdiff, ydiff);
	}
	
	public function getGear():Number
	{
		// gesuchter gang
		var gear:Number = 0;
		// unterscheiden zwischen beschleunigen und verlangsamen
		if (velocitydir >= 0) {
			// abschnitt bei aktueller geschwindigkeit
			var currentunit:Number = getCurrentVelocityUnit();
			// es gilt: currentunit = gear * (gear + 1) / 2
			// umformung | *2, -2*currentunit
			// => 0 = gear^2 + gear - 2*currentunit
			// es sei: gear = x, -2*currentunit = a0
			// quadratische gleichung a2x^2 + a1x + a0 = 0
			// es sei: a2 = 1, a1 = 1, a0 = -2*currentunit
			// umformung | a2
			// => normalform: x^2 + px + q = 0 
			// mit p = a1 / a2 (=1) und q = a0 / a2 (=-2*currentunit)
			// loesung: x1,2 = -p/2 +- sqr((p/2)^2 - q)
			var p:Number = 1;
			var q:Number = -2*currentunit;
			var x1:Number = -p/2 + Math.sqrt((p/2)*(p/2) - q);
			var x2:Number = -p/2 - Math.sqrt((p/2)*(p/2) - q);
			// gesuchter gang
			gear = Math.ceil(x1);
		} else {
			// linear runter schalten
			gear = Math.floor(velocity.getLength() / (VMAX / GEARS));
		}
		// minimum
		if (gear == 0) gear = 1;
		// deckeln
		if (gear > GEARS) gear = GEARS;
		// zurueck geben
		return gear;
	}
	
	public function getRelativeRPM():Number
	{
		// gesuchte relative drehzahl (zwischen 0 und 1)
		var rpm:Number;
		// aktueller gang
		var gear:Number = getGear();
		// unterscheiden zwischen beschleunigen und verlangsamen
		if (velocitydir >= 0) {
			// abschnitt bei aktueller geschwindigkeit
			var currentunit:Number = getCurrentVelocityUnit();
			// abschnitt am anfang des gangs
			var unitmin:Number = (gear - 1) * gear / 2;
			// abschnitt am ende des gangs
			var unitmax:Number = gear * (gear + 1) / 2;
			// gesuchte relative drehzahl (zwischen 0 und 1)
			rpm = (currentunit - unitmin) / (unitmax - unitmin);
		} else {
			// geschwindigkeit am anfang des gangs
			var vmin:Number = gear * (VMAX / GEARS);
			// geschwindigkeit am ende des gangs
			var vmax:Number = (gear + 1) * (VMAX / GEARS);
			// gesuchte relative drehzahl (zwischen 0 und 1)
			rpm = (velocity.getLength() - vmin) / (vmax - vmin);
			if (rpm > 1) trace(rpm);
		}
		// zurueck geben
		return rpm;
	}
	
	public function onChangeTrackpiece():Void {}
	
	private function updateVelocity():Void
	{
//		// winkel zwischen geschwindigkeit und beschleunigung
//		var angle:Number = Math.abs(velocity.getAngle() - acceleration.getAngle());
//		// testen, ob bremsen (sprich winkel entspricht PI)
//		if (angle.toString().substr(0, 4) == "3.14") {
//			// testen, ob fahrzeug gedreht wuerde (sprich negative beschleunigung groesser als geschwindigkeit)
//			if (acceleration.getLength() >= velocity.getLength()) {
////				trace("no brake");
//				// keine beschleunigung
//				acceleration.setLength(AMIN); // velocity.getLength() - VMIN
//			}
//		}
		// neue geschwindigkeit
		velocity.addVector(acceleration);
		// ggf. geschwindigkeit deckeln
		if (velocity.getLength() > VMAX) velocity.setLength(VMAX);
		// ggf. minimalgeschwindigkeit
		if (velocity.getLength() < VMIN) {
			// minimalgeschwindigkeit (wg. rundungsfehler / 2, sonst 1.0000001)
			velocity.setLength(VMIN / 2);
			// beschleunigung in richtung geschwindigkeit
			acceleration.setAngle(velocity.getAngle());
		}
		
		if (velocity.getLength() / lastlinearvelocity > 1) {
//			trace("faster");
			velocitydir = 1;
		} else if (velocity.getLength() / lastlinearvelocity < 0.98) {
//			trace("slower");
			velocitydir = -1;
		} else {
//			trace("equal");
			velocitydir = 0;
		}
//		if (type == TYPE_USER) trace(velocity.getLength() / lastlinearvelocity);
		
		// lineargeschwindigkeit, mit der das fahrzeug zuletzt gefahren ist
		lastlinearvelocity = velocity.getLength();
	}
	
	private function updatePosition():Void
	{
		// neue position
		position.movePoint(velocity);
	}
	
	private function updateMovieclip():Void
	{
		// movieclip positionieren
		movieclip.setPosition(position);
		// movieclip drehen
		movieclip.setRotation((angle + myAngleSlide) / Math.PI * 180);
	}
	
	private function getCurrentVelocityUnit():Number
	{
		// kleinster abschnitt auf geschwindigkeitsachse
		var vunit:Number = VMAX / (GEARS * (GEARS + 1) / 2);
		// abschnitt bei aktueller geschwindigkeit
		var currentunit:Number = velocity.getLength() / vunit;
		// zurueck geben
		return currentunit;
	}
	
	private function updateSound():Void
	{
		// sound updaten
		mySoundVelocity.setOffset(lastlinearvelocity / VMAX);
		// einblenden
		mySoundVelocity.setVolume(100);
	}
	
	private function bounceVehicle(angle:Number, repeat:Boolean ):Void
	{
		// geschwindigkeit drehen
		velocity.rotateBy(angle);
		// erstes oder zweites mal
		if (repeat) {
			// sound
			var snd:Sound = new Sound(movieclip);
			snd.attachSound("bounce");
			snd.start();
			// nach pause wieder drehen
			myInterval = setInterval(this, "bounceVehicle", 200, angle, false);
		} else {
			// abbremsen
			velocity.multiplyBy(0.1); // if (!controller.isVehicleOffRoad()) 
			// nur einmal
			clearInterval(myInterval);
		}
	}
	
	private function updateAcceleration():Void {}
	
	private function whileNotOnTrack():Void {}

}