/* 
 * Generated by ASDT 
*/

/*
klasse:			VehicleTest
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		04.06.2005
zuletzt bearbeitet:	06.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleTest extends Vehicle {
	
	private static var KEYS:Object = {left : Key.LEFT, right : Key.RIGHT, up : Key.UP, down : Key.SPACE};
	
	private static var ATTENUATION:Number = 25;
	
	private static var AMIN:Number = 1e-6; // minimale linearbeschleunigung
	
	private static var AMAX:Number = 0.3; // maximale linearbeschleunigung
	
	private static var AUP_ON:Number = 0.08 / ATTENUATION; // betrag beschleunigungsvektor beim gas geben auf strecke
	
	private static var AUP_OFF:Number = 0.1 / ATTENUATION; // betrag beschleunigungsvektor beim gas geben neben strecke
	
	private static var ABRAKE:Number = 4 / ATTENUATION; // betrag beschleunigungsvektor beim bremsen
	
	private static var AFRICTION_ON:Number = 0.2 / ATTENUATION; // betrag beschleunigungsvektor bei reibung auf strecke
	
	private static var AFRICTION_OFF:Number = 2 / ATTENUATION; // betrag beschleunigungsvektor bei reibung neben strecke
	
	private static var STEER_LEFT:Number = -1; // lenken nach links
	
	private static var STEER_RIGHT:Number = 1; // lenken nach rechts
	
	private static var STEER_ANGLE:Number = 90 / 180 * Math.PI; // maximaler lenkwinkel
	
	private static var STEER_TIME:Number = 1500; // lenkzeit bis erreichen maximaler lenkwinkel
	
	private static var STEER_VMIN:Number = VMAX * 0.05; // mindestgeschwindigkeit, ab der lenken erlaubt
	
	private static var BRAKE_TIME:Number = 1000; // bremszeit bis auftreten bremsspuren
	
	private static var BRAKE_VMIN:Number = VMAX * 0.8; // mindestgeschwindigkeit, ab der bremsspuren
	
	private var myInterval:Number;
	
	private var myAccelerationStatus:Boolean;
	
	private var myFriction:Vector;
	
	private var myBrake:Vector;
	
	private var mySteerTimeStart:Number;
	
	private var mySteerDirection:Number;
	
	private var myBrakeTimeStart:Number;
	
	private var myBrakeStatus:Boolean;
	
	public function VehicleTest() {
		// eigenschaften des vehicle
		super.constructor.apply(super, arguments);
		// typ des vehicles
		type = TYPE_USER;
		// status beim beschleunigen
		myAccelerationStatus = false;
		// reibungsvektor
		myFriction = new Vector(AFRICTION_ON, AFRICTION_ON);
		// bremsvektor
		myBrake = new Vector(ABRAKE, ABRAKE);
		// startzeitpunkt beim lenken
		mySteerTimeStart = getTimer();
		// letzte richtung beim lenken
		mySteerDirection = 0;
		// startzeitpunkt beim bremsen
		myBrakeTimeStart = getTimer();
		// status beim bremsen
		myBrakeStatus = false;
		// testendruck ueberwachen
		Key.addListener(this);
	}
	
	public function initVehicle(point:Point, angle:Number ):Void
	{
		// methode des vehicle
		super.initVehicle(point, angle);
		
		// reibungsvektor drehen
		myFriction.setAngle(velocity.getAngle());
		// bremsvektor drehen
		myBrake.setAngle(velocity.getAngle());
	}
	
	public function onUpdateStroke():Void
	{
		// testen, ob fahrzeug auf strecke
		ontrack = true; // controller.isVehicleOnTrack();
		// beschleunigung updaten
		updateAcceleration();
		// geschwindigkeit updaten
		updateVelocity();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// controller informieren
		RaceController.getInstance().onVehicleMove(this);
	}
	
	public function onKeyDown():Void
	{
		// beschleunigen startet
		if (Key.getCode() == KEYS.up && myAccelerationStatus == false) {
			trace(Math.abs(Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180)));
			// status beim beschleunigen
			myAccelerationStatus = true;
			// beschleunigung in richtung geschwindigkeit
			acceleration.setAngle(velocity.getAngle());
			// wenn langsam, lenken resetten
//			if (velocity.getLength() < STEER_VMIN) onSteer(0);
		}
	}
	
	public function onKeyUp():Void
	{
		// beschleunigen beendet
		if (Key.getCode() == KEYS.up) {
			// status beim beschleunigen
			myAccelerationStatus = false;
			// beschleunigung minimieren
			acceleration.setLength(AMIN);
			// beschleunigung in richtung geschwindigkeit
			acceleration.setAngle(velocity.getAngle());
		}
		// bremsen beendet
		if (Key.getCode() == KEYS.down) myBrakeStatus = false;
	}
	
	private function updateAcceleration():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// lenkrichtung
		var dirsteer:Number;
		// links
		if (kd(KEYS.left)) dirsteer = STEER_LEFT;
		// rechts
		if (kd(KEYS.right)) dirsteer = STEER_RIGHT;
		// geradeaus
		if (!kd(KEYS.left) && !kd(KEYS.right) || (kd(KEYS.left) && kd(KEYS.right))) dirsteer = 0;
		// lenkwinkel
		var sangle:Number = onSteer(dirsteer);
		
		// beschleunigen
		if (kd(KEYS.up)) {
			// beschleunigungsvektor
			var aup:Vector = onAccelerate();
			// beschleunigungsvektor addieren
			acceleration.addVector(aup);
			// bei lenken drehen
//			acceleration.setAngle(velocity.getAngle() + sangle);
		}
		// testen, ob schneller als mindestgeschwindigkeit
		if (velocity.getLength() > VMIN) {
			// bremsen
			if (kd(KEYS.down)) {
				// bremsvektor
				var abrake:Vector = onBrake();
				// bei lenken drehen
//				abrake.rotateBy(-sangle * 0.8);
				// bremsvektor addieren
				acceleration.addVector(abrake);
				
				// testen, ob gerade mit bremsen begonnen
				if (myBrakeStatus == false) {
					// testen, ob schnell genug
					if (velocity.getLength() > BRAKE_VMIN) {
						// startzeitpunkt beim bremsen
						myBrakeTimeStart = getTimer();
						// status beim bremsen
						myBrakeStatus = true;
					}
				// testen, ob bremsspur
				} else if (getTimer() - myBrakeTimeStart > BRAKE_TIME) {
					
//					trace("bremsspur");
				}
			// reibung
			} else {
				// reibungsvektor
				var afriction:Vector = onFriction();
				// bei lenken drehen
//				afriction.rotateBy(-sangle);
				// reibungsvektor addieren
				acceleration.addVector(afriction);
			}
		}
		// winkel zwischen beschleunigung und geschwindigkeit
		var rotation:Number = Math.abs(Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180));
		trace(rotation);
			acceleration.setAngle(velocity.getAngle() + sangle);
		// bei lenken drehen
		if (rotation >= 0 && rotation <= 90 || rotation >= 270 && rotation <= 360) {
//			acceleration.setAngle(velocity.getAngle() + sangle);
		} else if (rotation == 180) {
//			acceleration.rotateBy(-sangle);
		}
		// ggf. linearbeschleunigung deckeln
		if (acceleration.getLength() > AMAX) acceleration.setLength(AMAX);
	}
	
//	private function updateAcceleration():Void
//	{
//		// abkuerzung
//		var kd:Function = Key.isDown;
//		
//		// lenkrichtung
//		var dirsteer:Number;
//		// links
//		if (kd(KEYS.left)) dirsteer = STEER_LEFT;
//		// rechts
//		if (kd(KEYS.right)) dirsteer = STEER_RIGHT;
//		// geradeaus
//		if (!kd(KEYS.left) && !kd(KEYS.right) || (kd(KEYS.left) && kd(KEYS.right))) dirsteer = 0;
//		// lenkwinkel
//		var sangle:Number = onSteer(dirsteer);
//		
//		// bremsen oder beschleunigen
//		if (kd(KEYS.up)) {
//			// beschleunigungsvektor
//			var aup:Vector = onAccelerate();
//			// beschleunigungsvektor addieren
//			acceleration.addVector(aup);
//			// bei lenken drehen
//			acceleration.setAngle(velocity.getAngle() + sangle);
//			trace(acceleration.getLength() / AMAX);
//			
//		} else if (kd(KEYS.down) && velocity.getLength() > VMIN) {
//			// bremsvektor
//			var abrake:Vector = onBrake();
//			// bei lenken drehen
//			abrake.rotateBy(-sangle * 0.8);
//			// beschleunigung entspricht bremsvektor
//			acceleration.setDiff(abrake.xdiff, abrake.ydiff);
//			
//			// testen, ob gerade mit bremsen begonnen
//			if (myBrakeStatus == false) {
//				// testen, ob schnell genug
//				if (velocity.getLength() > BRAKE_VMIN) {
//					// startzeitpunkt beim bremsen
//					myBrakeTimeStart = getTimer();
//					// status beim bremsen
//					myBrakeStatus = true;
//				}
//			// testen, ob bremsspur
//			} else if (getTimer() - myBrakeTimeStart > BRAKE_TIME) {
//				
////				trace("bremsspur");
//			}
//		}
////		} else if (velocity.getLength() > VMIN) {
//			// reibungsvektor
//			var afriction:Vector = onFriction();
//			// bei lenken drehen
//			afriction.rotateBy(-sangle * 0.8);
//			// reibungsvektor addieren
//			acceleration.addVector(afriction);
//			// beschleunigung entspricht reibungsvektor
////			acceleration.setDiff(afriction.xdiff, afriction.ydiff);
////		}
//		// ggf. linearbeschleunigung deckeln
//		if (acceleration.getLength() > AMAX) acceleration.setLength(AMAX);
//	}
	
	private function onSteer(direction:Number ):Number
	{
		// abbrechen, wenn zu langsam
		if (velocity.getLength() < STEER_VMIN) return 0;
		// testen, ob richtung gewechselt
		if (direction != mySteerDirection) {
			// letzte richtung beim lenken
			mySteerDirection = direction;
			// startzeitpunkt beim lenken
			mySteerTimeStart = getTimer();
		}
		// dauer des lenkens
		var time:Number = getTimer() - mySteerTimeStart;
		// lenkwinkel (betrag)
		var sangle:Number = time / STEER_TIME * STEER_ANGLE;
		// deckeln
		if (sangle > STEER_ANGLE) sangle = STEER_ANGLE;
		// links / rechts
		sangle *= direction;
		// lenkung nimmt mit geschwindigkeit zu
//		sangle *= (velocity.getLength() / VMAX);
		// zurueck geben
		return sangle;
	}
	
	private function onAccelerate():Vector
	{
		// betrag beschleunigungsvektor
		var up:Number = (ontrack ? AUP_ON : AUP_OFF);
		// neuer beschleunigungsvektor
		var aup:Vector = new Vector(up, up);
		// in richtung der geschwindigkeit ausrichten
		aup.setAngle(acceleration.getAngle());
		// und zurueck geben
		return (aup);
	}
	
	private function onBrake():Vector
	{
		// neuer bremsvektor
		var abrake:Vector = new Vector(ABRAKE, ABRAKE);
		// winkel zwischen beschleunigung und geschwindigkeit
		var rotation:Number = Math.abs(Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180));
		// rueckwaerts oder vorwaerts gerichtet
		if (rotation == 180) {
			// in  richtung der beschleunigung ausrichten
			abrake.setAngle(acceleration.getAngle());
		} else {
			// in entgegengesetzter richtung der beschleunigung ausrichten
			abrake.setAngle(acceleration.getAngle() + Math.PI);
		}
		// bremskraft nimmt mit geschwindigkeit zu
		abrake.multiplyBy(velocity.getLength() / VMAX);
		// und zurueck geben
		return (abrake);
	}
	
	private function onFriction():Vector
	{
		// betrag reibungsvektor
		var friction:Number = (ontrack ? AFRICTION_ON : AFRICTION_OFF);
		// neuer reibungsvektor
		var afriction:Vector = new Vector(friction, friction);
		// winkel zwischen beschleunigung und geschwindigkeit
		var rotation:Number = Math.abs(Math.round((acceleration.getAngle() - velocity.getAngle()) / Math.PI * 180));
		// rueckwaerts oder vorwaerts gerichtet
		if (rotation == 180) {
			// in  richtung der beschleunigung ausrichten
			afriction.setAngle(acceleration.getAngle());
		} else {
			// in entgegengesetzter richtung der beschleunigung ausrichten
			afriction.setAngle(acceleration.getAngle() + Math.PI);
		}
		// reibung nimmt mit geschwindigkeit zu
		afriction.multiplyBy(velocity.getLength() / VMAX);
		// und zurueck geben
		return (afriction);
	}
}