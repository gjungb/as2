/* 
 * Generated by ASDT 
*/ 

/*
klasse:			VehicleUser
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	02.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.vehicle.VehicleUser extends Vehicle {
	
	private static var KEYS:Object = {left : Key.LEFT, right : Key.RIGHT, up : Key.UP, down : Key.SPACE};
	
	private static var DIRECTION_LEFT:Number = -1;
	
	private static var DIRECTION_RIGHT:Number = 1;
	
	private static var ACC_ROTATION:Number = 10 / 180 * Math.PI;
	
	private static var TIME_ROTATION:Number = 1500;
	
	private static var ACC_UP:Number = 0.2 / ATTENUATION; // 0.6
	
	private static var ACC_DOWN:Number = 6 / ATTENUATION;
	
//	private static var ACC_FRICTION:Number = 0.5 / ATTENUATION;
	
	private var myTimeStartBrake:Number;
	
	private var myTimeStartSteer:Number;
	
	private var myDirectionSteer:Number;
	
	public function VehicleUser()
	{
		// eigenschaften des vehicle
		super.constructor.apply(super, arguments);
		// typ des vehicles
		type = TYPE_USER;
		// startzeitpunkt beim bremsen
		myTimeStartBrake = getTimer();
		// startzeitpunkt beim lenken
		myTimeStartSteer = getTimer();
		// letzte richtung beim lenken
		myDirectionSteer = 0;
	}
	
	public function onUpdateStroke():Void
	{
		// beschleunigung updaten
		updateAcceleration();
		// geschwindigkeit updaten
		updateVelocity();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// testen, ob fahrzeug auf strecke
		ontrack = controller.isVehicleOnTrack();
		// was passiert, wenn das fahrzeug nicht auf der strecke ist?
		if (!ontrack) whileNotOnTrack();
		// sound updaten
		updateSound();
		// controller informieren
		RaceController.getInstance().onVehicleMove(this);
	}
	
	private function updateAcceleration():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		// links
		if (kd(KEYS.left)) onSteer(DIRECTION_LEFT);
		// rechts
		if (kd(KEYS.right)) onSteer(DIRECTION_RIGHT);
		// startzeitpunkt beim bremsen updaten
		if (!kd(KEYS.left) && !kd(KEYS.right) || (kd(KEYS.left) && kd(KEYS.right))) myTimeStartSteer = getTimer();
		// bremsen oder beschleunigen
		if (kd(KEYS.up)) {
			// beschleunigen
			onAccelerate();
		} else if (kd(KEYS.down)) {
			// bremsen
			onBrake();
		} else {
			// reibung, wenn nicht beschleunigen oder bremsen
			onFriction();
		}
		
		// ggf. linearbeschleunigung deckeln
		if (acceleration.getLength() > AMAX) acceleration.setLength(AMAX);
	}
	
	private function onSteer(direction:Number ):Void
	{
		// testen, ob richtung gewechselt
		if (direction != myDirectionSteer) {
			// letzte richtung beim lenken
			myDirectionSteer = direction;
			// startzeitpunkt beim lenken
			myTimeStartSteer = getTimer();
		}
		// dauer des lenkens
		var time:Number = getTimer() - myTimeStartSteer;
		// prozent einschlagen
		var steer:Number = time / TIME_ROTATION;
		// deckeln
		if (steer > 1) steer = 1;
		// beschleunigung drehen
		acceleration.setAngle(velocity.getAngle() + direction * steer * ACC_ROTATION);
		// geschwindigkeit drehen
		velocity.setAngle(velocity.getAngle() + 1.0 * direction * steer * ACC_ROTATION );
	}
	
	private function onAccelerate():Void
	{
		// aktueller winkel der geschwindigkeit
		var vangle:Number = velocity.getAngle();
		// vektor, der zur beschleunigung addiert werden soll
		var factor:Vector = new Vector(ACC_UP, ACC_UP);
		// vektor entsprechend ausrichten
		factor.setAngle(vangle);
		// neuen betrag speichern
		acceleration.addVector(factor);
	}
	
	private function onBrake():Void
	{
		// aktueller winkel der geschwindigkeit
		var vangle:Number = velocity.getAngle();
		// vektor, der von beschleunigung subtrahiert werden soll
		var brake:Vector = new Vector(ACC_DOWN, ACC_DOWN);
		// vektor entsprechend ausrichten
		brake.setAngle(vangle + Math.PI);
		// neuen betrag speichern
		acceleration.addVector(brake);
	}
	
	private function onFriction():Void
	{
//		// aktueller winkel der geschwindigkeit
//		var vangle:Number = velocity.getAngle();
//		// aktueller betrag der geschwindigkeit
//		var vlength:Number = velocity.getLength();
//		// vektor, der von beschleunigung subtrahiert werden soll
//		var friction:Vector = new Vector(1, 1);
//		// vektor entsprechend ausrichten
//		friction.setAngle(vangle + Math.PI);
//		// vektor entsprechend verlaengern
//		friction.setLength(vlength * 0.05);
//		// neuen betrag speichern
//		acceleration.addVector(friction);
		
		// beschleunigung aufheben
//		acceleration.setLength(0);
		// beschleunigung vermindern
		acceleration.multiplyBy(VFRICTION_ON);
		// geschwindigkeit vermindern
		velocity.multiplyBy(VFRICTION_ON);
	}
	
	private function whileNotOnTrack():Void
	{
		// beschleunigung vermindern
//		acceleration.setLength(AMAX_OFF);
		// beschleunigung vermindern
		acceleration.multiplyBy(VFRICTION_OFF);
		// geschwindigkeit vermindern
		velocity.multiplyBy(VFRICTION_OFF);
		// ggf. minimalgeschwindigkeit
		if (velocity.getLength() < VMIN) velocity.setLength(VMIN);
		// testen, ob fahrzeug auf streckenteil, das nicht befahren werden darf
		if (controller.isVehicleOffRoad()) {
			// minimalgeschwindigkeit
			velocity.setLength(VMIN);
			// keine beschleunigung
			acceleration.setLength(AMIN);
		}
	}
	
}