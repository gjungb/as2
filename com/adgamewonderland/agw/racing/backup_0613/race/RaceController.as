/* 
 * Generated by ASDT 
*/ 

/*
klasse:			RaceController
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		19.05.2005
zuletzt bearbeitet:	07.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.racing.race.*;

import com.adgamewonderland.agw.racing.track.*;

import com.adgamewonderland.agw.racing.vehicle.*;

class com.adgamewonderland.agw.racing.race.RaceController implements Strokable {
		
	private static var _instance : RaceController;
	
	private static var LAPS:Number = 3;
	
	private var myTrack:Track;
	
	private var myTrackUI:TrackUI;
	
	private var myMiniTrackUI:MiniTrackUI;
	
	private var myVehicles:Array;
	
	private var myStroke:StrokeUI;
	
	private var myTime:Number;
	
	private var myLap:Number;
	
	public static function getInstance():RaceController
	{
		if (_instance == null)
			_instance = new RaceController();
		return _instance;
	}
	
	public function set trackui(mc:TrackUI ):Void
	{
		// movieclip, das die strecke auf der buehne anzeigt
		myTrackUI = mc;
	}
	
	public function get trackui():TrackUI
	{
		// movieclip, das die strecke auf der buehne anzeigt
		return myTrackUI;
	}
	
	public function set minitrackui(mc:MiniTrackUI ):Void
	{
		// movieclip, das die ministrecke auf der buehne anzeigt
		myMiniTrackUI = mc;
	}
	
	public function get minitrackui():MiniTrackUI
	{
		// movieclip, das die ministrecke auf der buehne anzeigt
		return myMiniTrackUI;
	}
	
	public function get track():Track
	{
		// aktuelle strecke
		return myTrack;
	}
	
	public function loadTrack(id:Number ):Void
	{
		// laden lassen
		TrackFactory.getInstance().getTrack(id, this, "onTrackLoaded");
	}
	
	public function onTrackLoaded(tobj:Track ):Void
	{
		// aktuelle strecke
		myTrack = tobj;
		// anzeigen
		myTrackUI.showTrack(tobj);
		// initialisieren der inneren box, ausserhalb der die streckenanzeige nicht bewegt wird
		myTrackUI.initBoxInner(tobj.width, tobj.height);
		// streckenanzeige starten
		myTrackUI.startTrack();
		// ministrecke anzeigen
		myMiniTrackUI.showTrack(tobj.id);
		
		// fahrzeuge hinzufuegen TODO: startposition und -winkel je nach strecke
		addVehicle(Vehicle.TYPE_USER, new Point(5233, 1565), 328, 1);
//		addVehicle(Vehicle.TYPE_USER, new Point(2617, 783), 328);
		addVehicle(Vehicle.TYPE_COMPUTER, new Point(5287, 1699), 328, 2);
//		addVehicle(Vehicle.TYPE_COMPUTER, new Point(362, 1177), 245);
//		addVehicle(Vehicle.TYPE_USER, new Point(1463, 535), 175);
//		addVehicle(Vehicle.TYPE_COMPUTER, new Point(1485, 472), 175);
//		addVehicle(Vehicle.TYPE_COMPUTER, new Point(1593, 521), 175);
	}
	
	public function addVehicle(type:Number, pos:Point, angle:Number, carid:Number ):Void
	{
		// eindeutige id fuer neues fahrzeug
		var id:Number = myVehicles.length;
		// neues fahrzeug objekt
		var vobj;
		// neuer controller fuer fahrzeug
		var cobj:VehicleController;
		// movieclip, das fahrzeug auf buehne anzeigt
		var mc:VehicleUI;
		// je nach typ
		switch (type) {
			// user
			case (Vehicle.TYPE_USER) :
				// neues user-gesteuertes fahrzeug
//				var vobj = new VehicleUser(id);
//				var vobj = new VehicleTest(id);
				var vobj = new VehicleTest2(id);
				
				break;
			// computer
			case (Vehicle.TYPE_COMPUTER) :
				// neues computer-gesteuertes fahrzeug
				var vobj = new VehicleComputer(id);
				// staerke
				if (id == 1) vobj.strength = VehicleComputer.STRENGTH_MEDIUM;
				if (id == 2) vobj.strength = VehicleComputer.STRENGTH_SLOW;
			
				break;
			// unbekannt
			default :
				trace("addVehicle: " + type);
		}
		//  fahrzeug speichern
		myVehicles[id] = vobj;
		// movieclip, das fahrzeug auf buehne anzeigt
		mc = VehicleUI(myTrackUI.showVehicle("VehicleUI"));
		// fahrzeug initialisieren auf startposition
		vobj.initVehicle(mc, pos, angle / 180 * Math.PI);
		// movieclip initilisieren
		mc.initVehicleUI(vobj, carid);
		// einmal bewegen
		onVehicleMove(vobj);
	}
	
	public function startRace():Void
	{
		// alle fahrzeuge starten
		for (var i:String in myVehicles) {
			// aktuelles fahrzeug
			var vehicle:Vehicle = myVehicles[i];
			// starten
			vehicle.startVehicle();
		}
		// beim taktgeber anmelden
		myStroke.addListener(this);
		// taktgeber starten
//		_global.Stroke.active = true;
		// zoomen
//		myTrackUI.zoomTo(100);
	}
	
	public function onUpdateStroke():Void
	{
		// zeit zaehlen
		myTime += myStroke.fpsclip / myStroke.fpsstroke * 100;
		// anzeigen
		trackui._parent.counter_mc.showTime(Math.round(myTime));
	}
	
	public function onVehicleMove(vobj:Vehicle ):Void
	{
		// je nach typ
		switch (vobj.type) {
			// user
			case (Vehicle.TYPE_USER) :
				// position des fahrzeugs
				var pos:Point = vobj.position;
				// streckenanzeige positionieren
				myTrackUI.centerTo(pos);
//				// fragen, ob auf strecke
//				var ontrack:Boolean = vobj.ontrack;
				// infos anzeigen
				showRaceInfos(vobj);
				// geschwindigkeit anzeigen
				trackui._parent.tachometer_mc.showSpeed(vobj.velocity.getLength() / Vehicle.VMAX);
				// drehzahl anzeigen
				trackui._parent.revmeter_mc.rpm = vobj.getRelativeRPM();
				
//				trace(vobj.controller.getTrackpiece(VehicleController.TRACKPIECE_CURRENT).id + " # " + vobj.controller.getTrackpiece(VehicleController.TRACKPIECE_PREV).id + " # " + track.getNumTrackpieces());
				break;
			// computer
			case (Vehicle.TYPE_COMPUTER) :
				// position des fahrzeugs
				var pos:Point = vobj.position;
				// streckenanzeige positionieren
//				myTrackUI.centerTo(pos);
//				// fragen, ob auf strecke
//				var ontrack:Boolean = vobj.ontrack;
//				// infos anzeigen
//				showRaceInfos(ontrack);
			
				break;
			// unbekannt
			default :
				trace("onVehicleMove: " + vobj.type);
		}
		// auf ministrecke anzeigen
		minitrackui.showVehicle(vobj);
	}
	
	public function countLap(lap:Number ):Void
	{
		// anzeigen
		trackui._parent.counter_mc.showLap(lap, LAPS);
	}
	
//	public function getTrackpieceByPoint(point:Point ):TrackPiece
//	{
//		// laenge der strasse
//		var max:Number = myTrack.getNumTrackpieces();
//		// schleife ueber alle streckenteile
//		for (var i:Number = 0; i < max; i++) {
//			// aktuelles streckenteil
//			var trackpiece:TrackPiece = myTrack.getTrackpieceById(i);
//			// abbrechen, falls innerhalb
//			if (isPointOnTrackpiece(point, trackpiece) == true) return trackpiece;
//		}
//		// alle streckenteile negativ getestet
//		return null;
//	}
	
	public function getTrackpieceByPoint(point:Point ):TrackPiece
	{
		// streckenteile im raster rund um den punkt
		var pieces:Array = track.getTrackpiecesByPoint(point);
		// schleife ueber diese streckenteile
		for (var i:String in pieces) {
			// abbrechen, falls innerhalb
			if (isPointOnTrackpiece(point, pieces[i]) == true) return pieces[i];
		}
		// alle streckenteile negativ getestet
		return null;
	}
		
	private function RaceController()
	{
		// aktuelle strecke
		myTrack = null;
		// movieclip, das die strecke auf der buehne anzeigt
		myTrackUI = null;
		// fahrzeuge auf der strecke
		myVehicles = new Array();
		// rennzeit
		myTime = 0;
		// rennrunde
		myLap = 0;
		// taktgeber
		myStroke = _global.Stroke;
		// taktgeber starten
		_global.Stroke.active = true;
	}
	
//	private function isPointOnTrack(point:Point ):Boolean
//	{
//		// laenge der strasse
//		var max:Number = myTrack.getNumTrackpieces();
//		// schleife ueber alle streckenteile
//		for (var i:Number = 0; i < max; i++) {
//			// aktuelles streckenteil
//			var trackpiece:TrackPiece = myTrack.getTrackpieceById(i);
//			// abbrechen, falls innerhalb
//			if (isPointOnTrackpiece(point, trackpiece) == true) return true;
//		}
//		// alle streckenteile negativ getestet
//		return false;
//	}
	
	private function isPointOnTrackpiece(point:Point, tobj:TrackPiece ):Boolean
	{
		// entsprechendes polygon
		var polygon:Polygon = tobj.polygon;
		// testen
		var result:Boolean = LinearAlgebra.getInstance().isPointInPolygon(point, polygon);
		// zurueck geben
		return result;
	}
	
	private function showRaceInfos(vehicle:Vehicle ):Void
	{
//		// aktuelle werte aller fahrzeuge
//		for (var i : String in myVehicles) {
//			var i = 1;
//			// aktuelles fahrzeug
//			var vehicle:Vehicle = myVehicles[i];
			// position
			var position:Point = vehicle.position;
			// geschwindigkeit
			var velocity:Vector = vehicle.velocity;
			// beschleunigung
			var acceleration:Vector = vehicle.acceleration;
			// formatieren
			var str:String = "";
			str += "Position: x: + " + Math.round(position.x) + " y: " + Math.round(position.y);
			str += "\n";
			str += "Geschwindigkeit: " + velocity.getLength();
			str += "\n";
			str += "Beschleunigung: " + acceleration.getLength();
			str += "\n";
			str += "Auf Strecke: " + (vehicle.ontrack ? "JA" : "NEIN");
			str += "\n";
			str += "FPS: " + myStroke.fpsclip;
			
			// anzeigen
			_root.control_txt.text = str;
//		}
	}
}