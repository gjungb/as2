/* 
 * Generated by ASDT 
*/ 

/*
klasse:			ObstacleFactory
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		15.05.2005
zuletzt bearbeitet:	17.05.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.kicker.*;

class com.adgamewonderland.agw.kicker.ObstacleFactory {
	
	private static var TIMEOUT_DEFENDER:Object = {min : 5000, max : 10000};
	
	private static var XPOS_START:Object = {left : 100, right : 660};
	
	private static var YPOS_START:Number = 20;
	
	private static var DEPTH_MAX:Number = 1048575;
	
	private static var _instance:ObstacleFactory;
	
	private var myObstacles:Array;
	
	private var myTarget:MovieClip;
	
	private var myInterval:Number;
	
	public static function getInstance():ObstacleFactory {
		if (_instance == null)
			_instance = new ObstacleFactory();
		return _instance;
	}
	
	private function ObstacleFactory()
	{
		// aktuell angemeldete obstacles
		myObstacles = new Array();
		// ziel, auf das die obstacles attached werden
		myTarget = null;
		// interval
		myInterval = null;
	}
	
	public function startFactory(target:MovieClip ):Void
	{
		// ziel, auf das die obstacles attached werden
		myTarget = target;
		// neues obstacle
		nextObstacle();
	}
	
	public function stopFactory():Void
	{
	}
	
	public function registerObstacle(mc:ObstacleUI ):Number
	{
		// index im array der obstacles
		var id:Number = myObstacles.push(mc);
		// id zurueck geben
		return id;
	}
	
	public function unregisterObstacle(mc:ObstacleUI ):Void
	{
		// index im array der obstacles
		var id:Number = mc.id;
		// aus array loeschen
		myObstacles[id] = null;
		// von buehne loeschen
		mc.removeMovieClip();
	}
	
	private function nextObstacle():Void
	{
		// 1. interval loeschen
		clearInterval(myInterval);
		
		// 2. obstacle erzeugen
		addObstacle();
		
		// 3. nach pause neues obstacle
		// timeout, nach dem das naechste obstacle erzeugt wird
		var timeout:Number = getTimeout(ObstacleUI.TYPE_DEFENDER);
		// pause
		myInterval = setInterval(ObstacleFactory.getInstance(), "addObstacle", timeout);
	}
	
	private function addObstacle():Void
	{
		// 1. staerke des obstacles
		var strength:Number = Math.ceil(Math.random() * 3);
		
		// 2. position
		// links oder rechts
		var side:String = (Math.random() < 0.5 ? "left" : "right");
		// entsprechende x-position
		var xpos:Number = XPOS_START[side];
		// feste y-position
		var ypos:Number = YPOS_START;
		
		// 3. konstruktor
		var constructor:Object = new Object();
		// staerke
		constructor._myStrength = strength;
		// position
		constructor._x = xpos;
		constructor._y = ypos;
		
		// 4. tiefe
		var depth:Number = DEPTH_MAX - myObstacles.length;
		
		// 5. auf buehne
		var mc:ObstacleUI = ObstacleUI(myTarget.attachMovie("ObstacleDefenderUI", "obstacle_mc", depth, constructor));
	}
	
	private function getTimeout(type:Number ):Number
	{
		// timeout, nach dem das naechste obstacle erzeugt wird
		var timeout:Number = 5000;
		// je nach typ des obstacles
		switch (type) {
			// abwehr
			case ObstacleUI.TYPE_DEFENDER :
				// zufaelliger timeout
				timeout = Math.round(TIMEOUT_DEFENDER.min + Math.random() * (TIMEOUT_DEFENDER.max - TIMEOUT_DEFENDER.min));
				
				break;
			// special
			case ObstacleUI.TYPE_SPECIAL :
			
				break;
			// unbekannt
			default :
				trace("getTimeout: " + type);
			
		}
		// zurueck geben
		return timeout;
	}
}