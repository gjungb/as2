/* 
 * Generated by ASDT 
*/ 

/*
klasse:			BallUI
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		31.03.2005
zuletzt bearbeitet:	17.05.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.kicker.*;

class com.adgamewonderland.agw.kicker.BallUI extends MovieClip implements Strokable {
	
	private static var ATTENUATION:Object = {x : 1e-2, y : 1e-2};
	
	private static var BOUNCEFACTOR:Number = 3;
	
	private static var GRAVITY:Vector = new Vector(0, 9.81 * 1e-1);
	
	private static var REFLEXIONLOSS:Number = 0.9;
	
	private var _myStepDiff:Number;
	
	private var _myStrengthDiff:Number;
	
	private var _myTimeMove:Number;
	
	private var myKickerUI:KickerUI;
	
	private var myPosStart:Point;
	
	private var myPosAct:Point;
	
	private var myPosLinear:Point;
	
	private var myVelocities:Object;
	
	private var myStepAct:Number;
	
	private var myStrengthStart:Number;
	
	private var myStrengthAct:Number;
	
	private var myTimeReset:Number;
	
	public function BallUI()
	{
		// spiel
		myKickerUI = KickerUI(_parent);
		// startposition
		myPosStart = new Point(_x, _y);
		// aktuelle position
		myPosAct = new Point(_x, _y);
		// fiktive position bei linearer bewegung (zur berechnung des bodenkontakts)
		myPosLinear = new Point(_x, _y);
		// mehrere geschwindigkeiten
		myVelocities = {linear : null, bounce : null};
		// lineare geschwindigkeit (fuer perspektivische bewegung in richtung tor-aus)
		myVelocities["linear"] = new Vector(Number.MIN_VALUE, Number.MIN_VALUE);
		// huepf geschwindigkeit (fuer parabolische bewegung)
		myVelocities["bounce"] = new Vector(Number.MIN_VALUE, Number.MIN_VALUE);
		// aktueller schritt auf virtueller x-achse
		myStepAct = 0;
		// start schussstaerke
		myStrengthStart = 0;
		// aktuelle schussstaerke
		myStrengthAct = 0;
		// zeitpunkt, an dem der ball resettet wird
		myTimeReset = 0;
	}
	
	public function startBall(strength:Number ):Void
	{
		// startposition
		myPosStart.x = _x;
		myPosStart.y = _y;
		// fiktive position bei linearer bewegung (zur berechnung des bodenkontakts)
		myPosLinear.x = _x;
		myPosLinear.y = _y;
		// lineare geschwindigkeit (fuer perspektivische bewegung in richtung tor-aus)
		myVelocities["linear"].setDiff(ATTENUATION.x * strength * -1 * (KickerUI.VANISH.x - myPosStart.x) / (KickerUI.VANISH.y - myPosStart.y), -1 * ATTENUATION.y * strength);
		// huepf geschwindigkeit (fuer parabolische bewegung)
		myVelocities["bounce"].setDiff(0, -BOUNCEFACTOR * ATTENUATION.y * strength);
		// aktueller schritt auf virtueller x-achse
		myStepAct = 0;
		// start schussstaerke
		myStrengthStart = strength;
		// aktuelle schusstaerke
		myStrengthAct = strength;
		// zeitpunkt, an dem der ball resettet wird
		myTimeReset = getTimer() + _myTimeMove;
		// beim taktgeber anmelden
		_global.Stroke.addListener(this);
	}
	
	public function setPosition(xpos:Number, ypos:Number ):Void
	{
		// positionieren
		_x = myPosAct.x = xpos;
		_y = myPosAct.y = ypos;
	}
	
	public function getPosition():Point
	{
		// aktuelle position
		return myPosAct;
	}
	
	public function getPositionLinear():Point
	{
		// aktuelle fiktive position bei linearer bewegung
		return myPosLinear;
	}
	
	public function onUpdateStroke():Void
	{
		// 1. lineare bewegung (fuer perspektivische bewegung in richtung tor-aus)
		// position um linearen geschwindigkeitsvektor verschieben
		myPosAct.movePoint(myVelocities["linear"]);
		// fiktive position bei linearer bewegung um linearen geschwindigkeitsvektor verschieben
		myPosLinear.movePoint(myVelocities["linear"]);

		// 2. bewegung auf y-achse (in die hoehe)
		// y-achsen geschwindigkeitsvektor um gravitation aendern
		myVelocities["bounce"].addVector(GRAVITY);
		// position um y-achsen geschwindigkeitsvektor verschieben
		myPosAct.movePoint(myVelocities["bounce"]);
		// reflektieren, wenn am boden (sprich schnittpunkt aus linearer und y-achsen bewegung)
		if (myPosAct.y > myPosLinear.y) {
			// genau auf boden
			myPosAct.y = myPosLinear.y;
			// reflexion entspricht spiegelung an der x-achse, sprich ydiff * -1
			myVelocities["bounce"].setDiff(myVelocities["bounce"].xdiff, -1 * myVelocities["bounce"].ydiff);
			// verlust an energie
			myVelocities["bounce"].multiplyBy(REFLEXIONLOSS);
		}
		
		// 3. positionieren
		setPosition(myPosAct.x, myPosAct.y);
		
		// 4. skalieren
		// skalierung als quotient zwischen aktuellem y-abstand zum fluchtpunkt und startposition zum fluchtpunkt 
		var scale:Number = Math.round((KickerUI.VANISH.y - myPosAct.y) / (KickerUI.VANISH.y - myPosStart.y) * 100);
		// skalieren
		_xscale = _yscale = scale;
		
		// 5. spiel informieren, das den schatten positioniert und skaliert
		myKickerUI.onBallMove(myPosLinear, scale);
		
		// 6. resetten
		// resetten, wenn zeit abgelaufen
		if (getTimer() > myTimeReset) resetBall();
		// resetten, wenn am fluchtpunkt angekommen
		if (myPosAct.y < KickerUI.VANISH.y) resetBall();
	}
	
	public function resetBall():Void
	{
		// beim taktgeber abmelden
		_global.Stroke.removeListener(this);
		// skalieren
		_xscale = _yscale = 100;
		// spiel informieren
		myKickerUI.onBallReset();
		// fiktive position bei linearer bewegung (zur berechnung des bodenkontakts)
		myPosLinear.x = _x;
		myPosLinear.y = _y;
	}
}