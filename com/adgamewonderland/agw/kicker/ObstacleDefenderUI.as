/* 
 * Generated by ASDT 
*/

/*
klasse:			ObstacleDefenderUI
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		15.05.2005
zuletzt bearbeitet:	17.05.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.kicker.*; 

class com.adgamewonderland.agw.kicker.ObstacleDefenderUI extends ObstacleUI {
	
	private static var LINEAR_VELOCITY:Object = {min : 50, max : 100};
	
	private static var TIME_MOVE:Number = 2000;
	
	private static var ANIMATION_TIME_STEP:Number = 100;
	
	private static var ANIMATION_FRAME_LOOP:Number = 8;
	
	private static var DISTANCE_PLAYER_COLLISION:Number = 50;
	
	public static var STRENGTH_WEAK:Number = 1;
	
	public static var STRENGTH_MEDIUM:Number = 2;
	
	public static var STRENGTH_STRONG:Number = 3;
	
	private var _myStrength:Number;
	
	private var myPlayerUI:PlayerUI;
	
	private var myLinearVelocity:Number;
	
	private var myAnimationTimeStart:Number;
	
	private var myScale:Number;
	
	private var animation_mc:MovieClip;
	
	public function ObstacleDefenderUI()
	{
		// eigenschaften von ObstacleUI
		super();
		// typ des obstacles
		type = TYPE_DEFENDER;
		// hitarea
		myHitarea = new Rectangle(-_width / 2, -_height, _width, _height);
		
		// staerke des obstacles (wird im konstruktor beim attachen uebergeben)
		_myStrength = STRENGTH_STRONG;
		// spieler
		myPlayerUI = myKickerUI.getPlayer();
		// zufaellige lineare geschwindigkeit
		myLinearVelocity = LINEAR_VELOCITY.min + Math.random() * (LINEAR_VELOCITY.max - LINEAR_VELOCITY.min);
		// zeitpunkt, an dem das obstacle zuletzt animiert wurde
		myAnimationTimeStart = 0;
		// aktuelle skalierung
		myScale = 100;
		
		// animation entsprechend der starke anzeigen
		initAnimation();
		// starten
		startObstacle();
	}
	
	public function get strength():Number
	{
		// staerke des obstacles
		return _myStrength;
	}
	
	public function onMove():Void
	{
		// 1. animieren
		// testen, ob genuegend zeit seit letzter animation verstrichen
		if (getTimer() - myAnimationTimeStart >= ANIMATION_TIME_STEP) {
			// testen, ob am letzten frame angekommen
			if (animation_mc._currentframe < ANIMATION_FRAME_LOOP) {
				// naechster frame
				animation_mc.nextFrame();
			} else {
				// erster frame
				animation_mc.gotoAndStop("frWalk");
			}
			// zeitpunkt, an dem das obstacle zuletzt animiert wurde
			myAnimationTimeStart = getTimer();
		}
		
		// 2. testen, ob zusammenstoss mit ball
		// testen, ob der ball das obstacle trifft
		if (isBallColliding() == true) {
			// callback
			onBallCollision();
		}
		
		// 3. testen, ob zusammenstoss mit spieler
		// position des spielers
		var playerpos:Point = myPlayerUI.getPosition();
		// vector in richtung des spielers
		var direction:Vector = new Vector(myPosAct.x - playerpos.x, myPosAct.y - playerpos.y);
		// testen, ob naeher als erlaubt
		if (direction.getLength() <= DISTANCE_PLAYER_COLLISION) {
			// callback
			onPlayerCollision();
		}
		
		// 4. skalieren
//		// position des spielers
//		var playerpos:Point = myPlayerUI.getPosition();
		// skalierung als quotient zwischen aktuellem y-abstand zum spieler und spieler zum fluchtpunkt 
		var scale:Number = 100 - Math.round((playerpos.y - myPosAct.y) / (playerpos.y - KickerUI.VANISH.y) * 100);
		// skalieren
		setScale(scale);
	}
	
	public function onStopMove():Void
	{
		// starten
		startObstacle();
	}
	
	public function resetObstacle():Void
	{
	
	}
	
	private function startObstacle():Void
	{
		// position des spielers
		var playerpos:Point = myPlayerUI.getPosition();
		// vector in richtung des spielers
		myVelocity.setDiff(myPosAct.x - playerpos.x, myPosAct.y - playerpos.y);
		// auf zufaellige lineare geschwindigkeit kuerzen
		myVelocity.multiplyBy(myLinearVelocity / myVelocity.getLength());
		// startposition
		var pstart:Point = new Point(myPosAct.x, myPosAct.y);
		// zielposition
		var pend:Point = new Point(pstart.x - myVelocity.xdiff, pstart.y - myVelocity.ydiff);
		// bewegung starten
		myMover.startMove(Mover.MOVER_TYPE_LINEAR, pstart, pend, TIME_MOVE, new Object());
		// zeitpunkt, an dem das obstacle zuletzt animiert wurde
		myAnimationTimeStart = getTimer();
	}
	
	private function setScale(scale:Number ):Void
	{
		// skalieren
		_xscale = _yscale = scale;
	}
	
	private function onBallCollision():Void
	{
		// spiel informieren
		myKickerUI.onObstacleBallCollision(this);
	}
	
	private function onPlayerCollision():Void
	{
		// spiel informieren
		myKickerUI.onObstaclePlayerCollision(this);
	}
	
	private function initAnimation():Void
	{
		// counter
		var counter:Number = 0;
		// aktuelles movieclip
		var mc:MovieClip;
		// schleife ueber alle animations mcs auf der buehne
		while (typeof this["animation" + (++counter) + "_mc"] == "movieclip") {
			// aktuelles movieclip
			mc = this["animation" + counter + "_mc"];
			// testen, ob aktuell staerke des obstacles
			if (counter == _myStrength) {
				// dies ist die animation
				animation_mc = mc;
			} else {
				// loeschen
				mc.unloadMovie();
			}
		}
	}
	
}