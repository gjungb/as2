/* 
 * Generated by ASDT 
*/ 

/*
klasse:			KickerUI
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		31.03.2005
zuletzt bearbeitet:	17.05.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.kicker.*;

import com.adgamewonderland.agw.math.*;

import com.adgamewonderland.agw.physics.*;

import com.adgamewonderland.agw.util.*;

class com.adgamewonderland.agw.kicker.KickerUI extends MovieClip implements Playable {
	
	public static var VANISH:Point = new Point(310, -120);
	
	private var stroke_mc:StrokeUI;
	
	private var splash_mc:SplashUI;
	
	private var player_mc:PlayerUI;
	
	private var ball_mc:BallUI;
	
	private var shadow_mc:MovieClip;
	
	private var obstacles_mc:MovieClip;
	
	private var display_mc:DisplayUI;
	
	private var instructions_mc:MovieClip;
	
	public function KickerUI()
	{
		// bei splashscreen anmelden (wird auf zeitleiste gemacht)
//		splash_mc.registerGame(this);
	}
	
	public function onPlayerMove():Void
	{
		// position des balls am fuss des spielers
		var pos:Point = player_mc.getBallPosition();
		// ball positionieren
		ball_mc.setPosition(pos.x, pos.y);
		// schatten positionieren
		onBallMove(pos, 100);
	}
	
	public function onPlayerShoot(strength:Number ):Void
	{
		// ball starten
		ball_mc.startBall(strength);
	}
	
	public function onBallMove(ballpos:Point, scale:Number ):Void
	{
		// schatten positionieren
		shadow_mc._x = ballpos.x;
		shadow_mc._y = ballpos.y;
		// schatten skalieren
		shadow_mc._xscale = shadow_mc._yscale = scale;
	}
	
	public function onBallReset():Void
	{
		// position des balls am fuss des spielers
		var pos:Point = player_mc.getBallPosition();
		// ball positionieren
		ball_mc.setPosition(pos.x, pos.y);
		// schatten positionieren
		onBallMove(pos, 100);
		// schiessen erlauben
		player_mc.shooting = false;
	}
	
	public function onObstacleBallCollision(obstacle:ObstacleUI ):Void
	{
		// ball resetten
		ball_mc.resetBall();
		// typ des obstacles
		var type:Number = obstacle.type;
		// je nach typ des obstacles
		switch (type) {
			// tor
			case (ObstacleUI.TYPE_GOAL) :
				trace("tor");
				
				break;
			// abwehr
			case (ObstacleUI.TYPE_DEFENDER) :
				trace("abwehr");
				// TODO: punkte zaehlen
				
				// TODO: obstacle nach hinten bewegen
				
				// TODO: obstacle staerke abziehen
				
				// TEST: obstacle abmelden
				ObstacleFactory.getInstance().unregisterObstacle(obstacle);
				
				break;
			// special
			case (ObstacleUI.TYPE_SPECIAL) :
				trace("special");
				
				break;
			// unbekannt
			default :
				trace("onObstacleBallCollision: " + obstacle);
		}
	}
	
	public function onObstaclePlayerCollision(obstacle:ObstacleUI ):Void
	{
		// TODO: alles anhalten
		
		// spiel beenden
//		stopGame();
	}
	
	public function getPlayer():PlayerUI
	{
		// spieler
		return player_mc;
	}
	
	public function getBall():BallUI
	{
		// ball
		return ball_mc;
	}
	
	public function getDisplay():DisplayUI
	{
		// anzeige
		return display_mc;
	}

	public function showSplash():Void
	{
		// zum splashscreen
		gotoAndStop("frSplash");
	}
	
	public function showInstructions(bool:Boolean ):Void
	{
		// anleitung ein- / ausblenden
//		instructions_mc._visible = bool;
		// animieren
		instructions_mc.gotoAndPlay(bool ? "frIn" : "frOut");
	}
	
	public function showHighscore(editable:Boolean, score:Number ):Void
	{
		
	}
	
	public function startGame():Void
	{
		// taktgeber starten
		stroke_mc.active = true;
		// zum spiel
		gotoAndStop("frGame");
		// obstacles starten
		ObstacleFactory.getInstance().startFactory(obstacles_mc);
	}
	
	public function restartGame():Void
	{
	}
	
	public function stopGame():Void
	{
		// taktgeber stoppen
		stroke_mc.active = false;
		// highscoreliste zum eintragen anzeigen TODO: score
		showHighscore(true, 0);
	}
	
	public function toggleSound(bool:Boolean):Void
	{
		
	}
}