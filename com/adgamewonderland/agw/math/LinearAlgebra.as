/* 
 * Generated by ASDT 
*/ 

/*
klasse:			LinearAlgebra
autor: 			gerd jungbluth, adgame-wonderland
email:			gerd.jungbluth@adgame-wonderland.de
kunde:			agw
erstellung: 		18.05.2005
zuletzt bearbeitet:	21.06.2005
durch			gj
status:			in bearbeitung
*/

import com.adgamewonderland.agw.math.*;

class com.adgamewonderland.agw.math.LinearAlgebra {
	
	public static var POINT_LINE_RELATION_LEFT:Number = 1;
	
	public static var POINT_LINE_RELATION_RIGHT:Number = -1;
	
	public static var POINT_LINE_RELATION_ON:Number = 0;
	
	private static var HOMOGENIZER:Number = 1;
	
	private static var _instance:LinearAlgebra;
	
	public static function getInstance():LinearAlgebra
	{
		if (_instance == null)
			_instance = new LinearAlgebra();
		return _instance;
	}
	
	public function isPointInPolygon(point:Point, poly:Polygon ):Boolean
	{
		// raender des polygons
		var borders:Array = poly.borders;
		// letzte festgestellte relation
		var lastrelation:Number = 0;
		// schleife ueber die raender
		for (var i:Number = 0; i < borders.length; i++) {
			// relation zwischen punkt und rand
			var relation:Number = getPointBorderRelation(point, borders[i]);
			// punkt ist dann nicht im polygon, wenn relation innerhalb der schleife zwischen +1 und -1 wechselt
			// wenn 0, dann punkt in polygon
			if (relation == 0) return true;
			// testen, ob wechsel der relation
			if (lastrelation != 0 && relation != lastrelation) {
				// punkt nicht in polygon
				return false;	
			}
			// letzte festgestellte relation
			lastrelation = relation;
		}
		// punkt in polygon
		return true;
	}
	
	public function getPointBorderRelation(point:Point, border:Border ):Number
	{
		// gesuchte relation
		var relation:Number = null;
		
		// matrix zur berechnung der relation (1. spalte: punkt, 2. spalte: start des randes, 3. spalte: ende des randes)
		var a:Matrix = new Matrix();
		// 1. spalte: punkt
		a.addColumn(getHomogenousCoordinate(point));
		// 2. spalte: start des randes
		a.addColumn(getHomogenousCoordinate(border.getPoint("start")));
		// 3. spalte: ende des randes
		a.addColumn(getHomogenousCoordinate(border.getPoint("end")));
		
		// determinante der matrix
		var det:Number = a.getDeterminant();
		
		// entscheidung
		if (det < 0) {
			// rechts
			relation = POINT_LINE_RELATION_RIGHT;
		} else if (det > 0) {
			// links
			relation = POINT_LINE_RELATION_LEFT;
		} else {
			// auf
			relation = POINT_LINE_RELATION_ON;
		}
		
		// relation zurueck geben
		return relation;
	}
	
	public function getNumPolygonInPolygon(p1:Polygon, p2:Polygon ):Number
	{
		// gesuchte anzahl von ecken von p2, die innerhalb von p1 liegen
		var result:Number = 0;
		// anzahl ecken in p2
		var numpoints:Number = p2.getNumPoints();
		// schleife ueber alle ecken
		for (var i:Number = 1; i <= numpoints; i++) {
			// aktuelle ecke
			var point:Point = p2.getPoint(i);
			// zaehlen, wenn innerhalb von p1
			if (isPointInPolygon(point, p1)) result ++;
		}
		// anzahl zurueck geben
		return result;
	}
	
	public function getPointsInPolygon(p1:Polygon, p2:Polygon ):Array
	{
		// punkte von p2, die innerhalb von p1 liegen
		var points:Array = new Array();
		// anzahl ecken in p2
		var numpoints:Number = p2.getNumPoints();
		// schleife ueber alle ecken
		for (var i:Number = 1; i <= numpoints; i++) {
			// aktuelle ecke
			var point:Point = p2.getPoint(i);
			// zaehlen, wenn innerhalb von p1
			if (isPointInPolygon(point, p1)) points.push(point);
		}
		// punkte zurueck geben
		return points;
	}
	
	public function getBorderBorderIntersection(b1:Border, b2:Border ):Point
	{
		// in linien umformen
		var line1:Line = borderToLine(b1);
		var line2:Line = borderToLine(b2);
		// schnittpunkt zurueck geben
		return getLineLineIntersection(line1, line2);
	}	
	
	public function getPointPointDistance(p1:Point, p2:Point ):Number
	{
		// abstand zwischen den punkten
		var distance:Number;
		// x-abstand
		var xdiff:Number = p1.x - p2.x;
		// y-abstand
		var ydiff:Number = p1.y - p2.y;
		// satz des pythagoras
		distance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
		// zurueck geben
		return distance;
	}
	
//	public function getPointLineRelation(point:Point, line:Line ):Number
//	{
//		// gesuchte relation
//		var relation:Number = null;
//		
//		// steigung der geraden
//		var slope:Number = line.getSlope();
//		// y-achsenabschnitt der geraden
//		var intercept:Number = line.getIntercept();
//		
//		// sonderfall parallele zu x-achse
//		if (slope == 0) {
//			
//		} else {
//			// x-koordinate der geraden an x-koordinate des punktes
//			var xtest:Number = line.getX(point.y);
//			// x-abstand
//			var xdiff:Number = point.x - xtest;
//			// y-koordinate der geraden an x-koordinate des punktes
//			var ytest:Number = line.getY(point.x);
//			// y-abstand
//			var ydiff:Number = point.y - ytest;
//			
//			// unterscheiden zwischen positiver und negativer steigung
//			if (slope > 0) {
//				// relation ermitteln
//				if (ydiff > 0) {
//					// links
//					relation = POINT_LINE_RELATION_LEFT;
//				} else if (ydiff < 0) {
//					// rechts
//					relation = POINT_LINE_RELATION_RIGHT;	
//				} else {
//					// auf gerade
//					relation = POINT_LINE_RELATION_ON;	
//				}
//				
//			} else if (slope < 0) {
//				// relation ermitteln
//				if (ydiff > 0) {
//					// rechts
//					relation = POINT_LINE_RELATION_RIGHT;
//				} else if (ydiff < 0) {
//					// links
//					relation = POINT_LINE_RELATION_LEFT;	
//				} else {
//					// auf gerade
//					relation = POINT_LINE_RELATION_ON;	
//				}
//				
//			}
//		}
//		// relation zurueck geben
//		return relation;
//	}
	
	private function LinearAlgebra() {
		
	}
	
	private function getHomogenousCoordinate(point:Point ):ColumnVector
	{
		// gewuenschter spalten-vektor fuer homogene koordinaten
		var cv:ColumnVector = new ColumnVector(HOMOGENIZER * point.x, HOMOGENIZER * point.y, HOMOGENIZER);
		// zurueck geben
		return cv;
	}
	
	private function borderToLine(border:Border ):Line
	{
		// steigung
		var slope:Number = (border.getPoint("end").y - border.getPoint("start").y) / (border.getPoint("end").x - border.getPoint("start").x);
		// neue linie durch ursprung
		var line:Line = new Line(0, slope);
		// in den startpunkt verschieben
		line.moveToPoint(border.getPoint("start"));
		// segmentieren
		line.segmentLine(border.getPoint("start").x, border.getPoint("end").x);
		// zurueck geben
		return line;
	}
	
	private function getLineLineIntersection(line1:Line , line2:Line ):Point
	{
		// achsenabschnitt 1. linie
		var b1 = line1.getIntercept();
		// achsenabschnitt 2. linie
		var b2 = line2.getIntercept();
		// steigung 1. linie
		var m1 = line1.getSlope();
		// steigung 2. linie
		var m2 = line2.getSlope();
		// x-schnittpunkt
		var x = (b2 - b1) / (m1 - m2);
		// parallelen abfangen
		if (m1 == m2) x = Number.MAX_VALUE;
		// y-schnittpunkt
		var y = m1 * x + b1;

		// schnittpunkt zurueck geben
		return(new Point(x, y));
	}
}