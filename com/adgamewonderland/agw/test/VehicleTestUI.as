/* 
 * Generated by ASDT 
*/ 

import com.adgamewonderland.agw.math.*;

class com.adgamewonderland.agw.test.VehicleTestUI extends MovieClip {
	
	private static var KEYS:Object = {left : Key.LEFT, right : Key.RIGHT, up : Key.UP, down : Key.SPACE};
	
	private static var VMIN:Number = 1e-2; // minimale lineargeschwindigkeit
	
	private static var VMAX:Number = 20; // maximale lineargeschwindigkeit
	
	private static var ATTENUATION:Number = 25;
	
	private static var AMIN:Number = 1e-6; // minimale linearbeschleunigung
	
	private static var AMAX:Number = 1; // maximale linearbeschleunigung
	
	private static var AUP:Number = 0.2 / ATTENUATION; // betrag beschleunigungsvektor beim gas geben
	
	private static var ABRAKE:Number = 40 / ATTENUATION; // betrag beschleunigungsvektor beim bremsen
	
	private static var AFRICTION:Number = 10 / ATTENUATION; // betrag beschleunigungsvektor bei reibung
	
	private static var STEER_LEFT:Number = -1; // lenken nach links
	
	private static var STEER_RIGHT:Number = 1; // lenken nach rechts
	
	private static var STEER_ANGLE:Number = 90 / 180 * Math.PI; // maximaler lenkwinkel
	
	private static var STEER_TIME:Number = 1500; // lenkzeit bis erreichen maximaler lenkwinkel
	
	private static var INTERVAL:Number = 100;
	
	private var myPosition:Point;
	
	private var myVelocity:Vector;
	
	private var myAcceleration:Vector;
	
	private var myInterval:Number;
	
	private var mySteerTimeStart:Number;
	
	private var mySteerDirection:Number;
	
	public function VehicleTestUI() {
		// position
		myPosition = new Point(_x, _y);
		// geschwindigkeit
		myVelocity = new Vector(VMIN, VMIN);
		// beschleunigung
		myAcceleration = new Vector(0, 0);
		// startzeitpunkt beim lenken
		mySteerTimeStart = getTimer();
		// letzte richtung beim lenken
		mySteerDirection = 0;
		
		Key.addListener(this);
	}

	public function get position():Point
	{
		// aktuelle position
		return myPosition;
	}

	public function get velocity():Vector
	{
		// aktuelle geschwindigkeit
		return myVelocity;
	}

	public function get acceleration():Vector
	{
		// aktuelle beschleunigung
		return myAcceleration;
	}
	
	public function startVehicle():Void
	{
		// interval starten
		myInterval = setInterval(this, "moveVehicle", INTERVAL);
	}
	
	public function stopVehicle():Void
	{
		// interval stoppen
		clearInterval(myInterval);
	}
	
	public function moveVehicle():Void
	{
		// beschleunigung updaten
		updateAcceleration();
		// geschwindigkeit updaten
		updateVelocity();
		// position updaten
		updatePosition();
		// movieclip updaten
		updateMovieclip();
		// informationen anzeigen
		showRaceInfos();
	}
	
	public function onKeyDown():Void
	{
		// beschleunigen startet
		if (Key.getCode() == KEYS.up) acceleration.setAngle(velocity.getAngle());
	}
	
	public function onKeyUp():Void
	{
		// beschleunigen beendet
		if (Key.getCode() == KEYS.up) acceleration.setLength(AMIN);
	}
	
	private function updateAcceleration():Void
	{
		// abkuerzung
		var kd:Function = Key.isDown;
		
		// lenkrichtung
		var dirsteer:Number;
		// links
		if (kd(KEYS.left)) dirsteer = STEER_LEFT;
		// rechts
		if (kd(KEYS.right)) dirsteer = STEER_RIGHT;
		// geradeaus
		if (!kd(KEYS.left) && !kd(KEYS.right) || (kd(KEYS.left) && kd(KEYS.right))) dirsteer = 0;
		// lenkwinkel
		var sangle:Number = onSteer(dirsteer);
		
		// bremsen oder beschleunigen
		if (kd(KEYS.up)) {
			// beschleunigungsvektor
			var aup:Vector = onAccelerate();
			// beschleunigungsvektor addieren
			acceleration.addVector(aup);
			// bei lenken drehen
			acceleration.setAngle(velocity.getAngle() + sangle);
		} else if (kd(KEYS.down) && velocity.getLength() > VMIN) {
			// bremsvektor
			var abrake:Vector = onBrake();
			// bei lenken drehen
			abrake.rotateBy(-sangle / 2);
			// beschleunigung entspricht bremsvektor
			acceleration.setDiff(abrake.xdiff, abrake.ydiff);
		} else if (velocity.getLength() > VMIN) {
			// reibungsvektor
			var afriction:Vector = onFriction();
			// bei lenken drehen
			afriction.rotateBy(-sangle / 2);
			// beschleunigung entspricht reibungsvektor
			acceleration.setDiff(afriction.xdiff, afriction.ydiff);
		}
		// ggf. linearbeschleunigung deckeln
		if (acceleration.getLength() > AMAX) acceleration.setLength(AMAX);
	}
	
	private function onSteer(direction:Number ):Number
	{
		// testen, ob richtung gewechselt
		if (direction != mySteerDirection) {
			// letzte richtung beim lenken
			mySteerDirection = direction;
			// startzeitpunkt beim lenken
			mySteerTimeStart = getTimer();
		}
		// dauer des lenkens
		var time:Number = getTimer() - mySteerTimeStart;
		// lenkwinkel (betrag)
		var sangle:Number = time / STEER_TIME * STEER_ANGLE;
		// deckeln
		if (sangle > STEER_ANGLE) sangle = STEER_ANGLE;
		// links / rechts
		sangle *= direction;
		// lenkung nimmt mit geschwindigkeit zu
		sangle *= (velocity.getLength() / VMAX);
		// zurueck geben
		return sangle;
	}
	
	private function onAccelerate():Vector
	{
		// neuer beschleunigungsvektor
		var aup:Vector = new Vector(AUP, AUP);
		// in richtung der geschwindigkeit ausrichten
		aup.setAngle(acceleration.getAngle());
		// und zurueck geben
		return (aup);
	}
	
	private function onBrake():Vector
	{
		// neuer bremsvektor
		var abrake:Vector = new Vector(ABRAKE, ABRAKE);
		// in entgegengesetzter richtung der geschwindigkeit ausrichten
		abrake.setAngle(velocity.getAngle() + Math.PI);
		// bremskraft nimmt mit geschwindigkeit zu
		abrake.multiplyBy(velocity.getLength() / VMAX);
		// und zurueck geben
		return (abrake);
	}
	
	private function onFriction():Vector
	{
		// neuer reibungsvektor
		var afriction:Vector = new Vector(AFRICTION, AFRICTION);
		// in entgegengesetzter richtung der geschwindigkeit ausrichten
		afriction.setAngle(velocity.getAngle() + Math.PI);
		// reibung nimmt mit geschwindigkeit zu
		afriction.multiplyBy(velocity.getLength() / VMAX);
		// und zurueck geben
		return (afriction);
	}
	
	private function updateVelocity():Void
	{
		// neue geschwindigkeit
		velocity.addVector(acceleration);
		// ggf. geschwindigkeit deckeln
		if (velocity.getLength() > VMAX) velocity.setLength(VMAX);
		// ggf. minimalgeschwindigkeit
		if (velocity.getLength() < VMIN) velocity.setLength(VMIN);
	}
	
	private function updatePosition():Void
	{
		// neue position
		position.movePoint(velocity);
	}
	
	private function updateMovieclip():Void
	{
		// movieclip positionieren
		_x = position.x;
		_y = position.y;
		// movieclip drehen
		_rotation = velocity.getAngle() / Math.PI * 180;
	}
	
	private function showRaceInfos():Void
	{
		// formatieren
		var str:String = "";
		str += "Position:\n x: + " + Math.round(position.x) + " y: " + Math.round(position.y);
		str += "\n";
		str += "Geschwindigkeit:\n " + velocity.getLength();
		str += "\n";
		str += "Beschleunigung:\n " + acceleration.getLength();
		str += "\n";
		str += "Winkel:\n " + velocity.getAngle() / Math.PI * 180;
		
		// anzeigen
		_root.control_txt.text = str;
	}
}