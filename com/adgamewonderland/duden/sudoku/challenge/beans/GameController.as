import com.adgamewonderland.duden.sudoku.challenge.beans.User;import com.adgamewonderland.duden.sudoku.challenge.beans.Sudoku;import com.adgamewonderland.agw.util.IEventBroadcaster;import com.adgamewonderland.agw.util.EventBroadcaster;import com.adgamewonderland.duden.sudoku.challenge.beans.GameStatus;import com.adgamewonderland.duden.sudoku.challenge.beans.Term;import com.adgamewonderland.duden.sudoku.game.beans.Grid;import mx.rpc.ResultEvent;import mx.remoting.debug.NetDebug;import com.adgamewonderland.duden.sudoku.challenge.connectors.ChallengeConnector;import com.adgamewonderland.agw.net.RemotingBeanCaster;import com.adgamewonderland.duden.sudoku.challenge.connectors.UserConnector;import com.adgamewonderland.duden.sudoku.challenge.beans.Statistics;import com.adgamewonderland.duden.sudoku.challenge.beans.Result;import com.adgamewonderland.duden.sudoku.challenge.beans.Challenge;import com.adgamewonderland.duden.sudoku.challenge.beans.ChallengeImpl;import com.adgamewonderland.duden.sudoku.challenge.beans.ChallengeDetail;/** * @author gerd */class com.adgamewonderland.duden.sudoku.challenge.beans.GameController implements IEventBroadcaster {	private static var instance:GameController;	private static var EVENT_CHANGESTATUS:String = "onChangeStatus";	private static var EVENT_USERLOGGEDIN:String = "onUserLogin";	private static var EVENT_USERLOGGEDOUT:String = "onUserLogout";	private static var EVENT_USERUPDATED:String = "onUserUpdate";	private var event:EventBroadcaster;	private var gamestatus:GameStatus;	private var user:User;	private var email:String;	private var opponentemail:String;	private var opponent:User;	private var difficulty:Number;	private var challenge:ChallengeImpl;	private var result:Result;	/**	 * @return singleton instance of GameController	 */	public static function getInstance():GameController {		if (instance == null)			instance = new GameController();		return instance;	}	private function GameController() {		// event broadcaster		this.event = new EventBroadcaster();		// eingeloggter user		this.user = new User();		// spielstatus		this.gamestatus = new GameStatus(GameStatus.STATUS_NONE);		// email des gegners		this.opponentemail = "";		// bekannter gegener		this.opponent = new User();		// gewaehlter schwierigkeitsgrad		this.difficulty = Sudoku.DIFFICULTY_MEDIUM;		// aktuelle herausforderung		this.challenge = new ChallengeImpl();		// spielergebnis des sudoku		this.result = new Result();	}	public function changeStatus(newstatus:GameStatus ):Void	{		// bisheriger status		var oldstatus:GameStatus = getGamestatus();		// neuer status		setGamestatus(newstatus);		// listener informieren		event.send(EVENT_CHANGESTATUS, oldstatus, newstatus);	}	public function loginUser(user:User):Void	{		// user speichern		setUser(user);		// anzuzeigender spielstatus		var gamestatus:GameStatus;		// testen, ob herausforderung vorhanden		if (isChallenge()) {			// je nach status			switch (getChallenge().getStatus()) {				// herausforderer fertig => gegner soll spielen				case Challenge.STATUS_CHALLENGER_DONE :					// zur statistik uebersicht					gamestatus = new GameStatus(GameStatus.STATUS_COMPARISON);					break;				// gegner fertig => gegner soll siegerehrung ansehen				case Challenge.STATUS_OPPONENT_DONE :				case Challenge.STATUS_OPPONENT_AWARDED :					// zur siegerehrung					gamestatus = new GameStatus(GameStatus.STATUS_AWARD);					break;				// gegner fertig => herausforderer soll siegerehrung ansehen				case Challenge.STATUS_CHALLENGER_AWARDED :					// zur siegerehrung					gamestatus = new GameStatus(GameStatus.STATUS_AWARD);					break;				// keine ahnung				default :					// neue herausforderung					gamestatus = new GameStatus(GameStatus.STATUS_CHALLENGE);			}		} else {			// neue herausforderung			gamestatus = new GameStatus(GameStatus.STATUS_CHALLENGE);		}		// status aendern		changeStatus(gamestatus);		// listener informieren		event.send(EVENT_USERLOGGEDIN, getUser());	}	public function logoutUser():Void	{		// user resetten		setUser(new User());		// challenge resetten		setChallenge(new ChallengeImpl());		// login		changeStatus(new GameStatus(GameStatus.STATUS_LOGIN));		// listener informieren		event.send(EVENT_USERLOGGEDOUT, getUser());	}	public function loadOpponent(email:String ) {		// bisherigen gegner resetten		setOpponent(new User());		// email des gegners		setOpponentemail(email);		// gegner laden lassen		UserConnector.loadOpponent(email, this, "onOpponentLoaded");	}	public function onOpponentLoaded(re:ResultEvent ):Void	{		// testen, ob gegner in db bekannt		if (re.result["ID"] > 0) {			// bekannter gegner			var opponent:User = User(RemotingBeanCaster.getCastedInstance(new User(), re.result));		} else {			// neuer gegner			var opponent:User = getOpponent();		}		// statistics des gegners		opponent.setStatistics(Statistics(re.result["statistics"]));		// gegner speichern		setOpponent(opponent);		// difficulty formular		changeStatus(new GameStatus(GameStatus.STATUS_DIFFICULTY));	}	public function startSudoku():Void	{		// unterscheidung, ob herausforderung angenommen wurde		if (isChallenge()) {			// sudoku und term an grid melden			Grid.getInstance().initGrid(challenge.getSudoku(), challenge.getTerm());			// starten			changeStatus(new GameStatus(GameStatus.STATUS_SUDOKU));		} else {			// sudoku und loesungswort laden			ChallengeConnector.loadSudoku(getDifficulty(), this, "onSudokuLoaded");		}	}	public function onSudokuLoaded(re:ResultEvent ):Void	{		// sudoku		var sudoku:Sudoku = Sudoku(RemotingBeanCaster.getCastedInstance(new Sudoku(), re.result["sudoku"]));		// in challenge speichern		getChallenge().setSudoku(sudoku);		// term		var term:Term = Term(RemotingBeanCaster.getCastedInstance(new Term(), re.result["term"]));		// in challenge speichern		getChallenge().setTerm(term);		// sudoku und term an grid melden		Grid.getInstance().initGrid(getChallenge().getSudoku(), getChallenge().getTerm());		// starten		changeStatus(new GameStatus(GameStatus.STATUS_SUDOKU));	}	public function cancelSudoku():Void	{		// kein gegner		setOpponent(new User());		setOpponentemail("");		// keine herausforderung		setChallenge(new ChallengeImpl());		// eingeloggt oder nicht		switch (isUserLoggedIn()) {			// eingeloggt			case true :				// challenge				changeStatus(new GameStatus(GameStatus.STATUS_CHALLENGE));				break;			// nicht eingeloggt			case false :				// login				changeStatus(new GameStatus(GameStatus.STATUS_LOGIN));				break;		}	}	public function finishSudoku(time:Number, errors:Number, penaltytime:Number, score:Number ):Void	{		// neues spielergebnis		var result:Result = new Result();		// spielzeit		result.setTime(time);		// fehler		result.setErrors(errors);		// strafzeit		result.setPenaltytime(penaltytime);		// punktzahl		result.setScore(score);		// ergebnis speichern		setResult(result);		// gameover formular		changeStatus(new GameStatus(GameStatus.STATUS_GAMEOVER));	}	public function sendChallenge():Void	{		// herausforderung auf server initialisieren		ChallengeConnector.initChallenge(getUser(), getOpponentemail(), getChallenge().getSudoku(), getChallenge().getTerm(), getResult(), this, "onChallengeSent");	}	public function onChallengeSent(re:ResultEvent ):Void	{		// herausforderung wurde gesendet		if (re.result == 1) {			// status aendern			changeStatus(new GameStatus(GameStatus.STATUS_CHALLENGESENT));		} else {			// TODO: fehlerbehandlung		}	}	public function loadChallenge(email:String, hashkey:String ):Void	{		// e-mail des users, der die herausforderung / siegerehrung erhalten hat		setEmail(email);		// herausforderung laden		ChallengeConnector.loadChallenge(hashkey, this, "onChallengeLoaded");	}	public function onChallengeLoaded(re:ResultEvent ):Void	{		// herausforderung casten		var challenge:ChallengeImpl = getCastedChallenge(re);		// anzuzeigender spielstatus		var gamestatus:GameStatus;		// verzweigung je nach status der herausforderung		switch (challenge.getStatus()) {			// herausforderer fertig => gegner soll spielen			case Challenge.STATUS_CHALLENGER_DONE :				// testen, ob uebergebene email zum gegner passt				if (challenge.getDetail(ChallengeDetail.MODE_CHALLENGER).getOpponentemail() == getEmail()) {					// urspruenglichen herausforderer als gegner speichern					setOpponent(challenge.getDetail(ChallengeDetail.MODE_CHALLENGER).getUser());					// testen, ob gegner schon eingeloggt					if (getUser().getEmail() == getEmail()) {						// zur statistik uebersicht						gamestatus = new GameStatus(GameStatus.STATUS_COMPARISON);					} else {						// zum login						gamestatus = new GameStatus(GameStatus.STATUS_LOGIN);					}				} else {					// neue herausforderung					challenge = new ChallengeImpl();					// zum login					gamestatus = new GameStatus(GameStatus.STATUS_LOGIN);				}				break;			// gegner fertig => gegner soll siegerehrung ansehen			case Challenge.STATUS_OPPONENT_DONE :			case Challenge.STATUS_OPPONENT_AWARDED :				// testen, ob gegner schon eingeloggt				if (getUser().getEmail() == getEmail()) {					// zur siegerehrung					gamestatus = new GameStatus(GameStatus.STATUS_AWARD);				} else {					// zum login					gamestatus = new GameStatus(GameStatus.STATUS_LOGIN);				}				break;			// gegner fertig => herausforderer soll siegerehrung ansehen			case Challenge.STATUS_CHALLENGER_AWARDED :				// testen, ob herausforderer schon eingeloggt				if (getUser().getEmail() == getEmail()) {					// zur siegerehrung					gamestatus = new GameStatus(GameStatus.STATUS_AWARD);				} else {					// zum login					gamestatus = new GameStatus(GameStatus.STATUS_LOGIN);				}				break;			// anderer status			default :				// zum login				gamestatus = new GameStatus(GameStatus.STATUS_LOGIN);		}		// challenge speichern		setChallenge(challenge);		// status aendern		changeStatus(gamestatus);	}	public function finishChallenge():Void	{		// herausforderung auf server beenden		ChallengeConnector.finishChallenge(getUser(), getChallenge().getHashkey(), getResult(), this, "onChallengeFinished");	}	public function onChallengeFinished(re:ResultEvent ):Void	{		// herausforderung wurde beendet		if (re.result == 1) {			// status aendern			changeStatus(new GameStatus(GameStatus.STATUS_CHALLENGEFINISHED));		} else {			// TODO: fehlerbehandlung		}	}	public function loadAward():Void	{		// email des eingeloggten users		var email:String = getUser().getEmail();		// hashkey der aktuellen herausforderung		var hashkey:String = getChallenge().getHashkey();		// herausforderung laden		loadChallenge(email, hashkey);	}	public function finishAward():Void	{		// kein gegner		setOpponent(new User());		setOpponentemail("");		// keine herausforderung		setChallenge(new ChallengeImpl());		// challenge		changeStatus(new GameStatus(GameStatus.STATUS_CHALLENGE));	}	public function isUserLoggedIn():Boolean	{		// eingeloggt oder nicht		return (getUser().getID() > 0);	}	public function isOpponentRegistered():Boolean	{		// gegner in db bekannt oder nicht		return (getOpponent().getID() > 0);	}	public function isTraining():Boolean	{		// handelt es sich um ein trainingsspiel oder nicht		return (getOpponentemail() == "");	}	public function isChallenge():Boolean	{		// handelt es sich um eine herausforderung oder nicht		return (getChallenge().getID() > 0);	}	public function addListener(l:Object):Void {		// als listener registrieren		this.event.addListener(l);	}	public function removeListener(l:Object):Void {		// als listener abmelden		this.event.removeListener(Object(l));	}	public function getUser():User {		return user;	}	public function setUser(user:User):Void {		this.user = user;	}	public function getGamestatus():GameStatus {		return gamestatus;	}	public function setGamestatus(gamestatus:GameStatus ):Void {		this.gamestatus = gamestatus;	}	public function setEmail(email:String ):Void {		this.email = email;	}	public function getEmail():String {		return this.email;	}	public function setOpponentemail(opponentemail:String ):Void {//		this.opponentemail = opponentemail;		getOpponent().setEmail(opponentemail);	}	public function getOpponentemail():String {//		return this.opponentemail;		return getOpponent().getEmail();	}	public function getOpponent():User {		return opponent;	}	public function setOpponent(opponent:User):Void {		this.opponent = opponent;	}	public function setDifficulty(difficulty:Number ):Void {		this.difficulty = difficulty;	}	public function getDifficulty():Number {		return this.difficulty;	}	public function setChallenge(challenge:ChallengeImpl ):Void {		this.challenge = challenge;	}	public function getChallenge():ChallengeImpl {		return this.challenge;	}	public function getResult():Result {		return result;	}	public function setResult(result:Result):Void {		this.result = result;	}	private function getCastedChallenge(re:ResultEvent ):ChallengeImpl	{		// challenge		var challenge:ChallengeImpl = ChallengeImpl(RemotingBeanCaster.getCastedInstance(new ChallengeImpl(), re.result));		// sudoku		var sudoku:Sudoku = Sudoku(RemotingBeanCaster.getCastedInstance(new Sudoku(), re.result["sudoku"]));		// in challenge speichern		challenge.setSudoku(sudoku);		// term		var term:Term = Term(RemotingBeanCaster.getCastedInstance(new Term(), re.result["term"]));		// in challenge speichern		challenge.setTerm(term);		// detail des herausforderers		var detail:ChallengeDetail = ChallengeDetail(RemotingBeanCaster.getCastedInstance(new ChallengeDetail(), re.result["details"][ChallengeDetail.MODE_CHALLENGER]));		// user in detail speichern		detail.setUser(User(RemotingBeanCaster.getCastedInstance(new User(), detail.getUser())));		// result in detail speichern		detail.setResult(Result(RemotingBeanCaster.getCastedInstance(new Result(), detail.getResult())));		// in challenge speichern		challenge.addDetail(ChallengeDetail.MODE_CHALLENGER, detail);		// testen, ob gegner schon gespielt hat		if (challenge.getStatus() >= Challenge.STATUS_OPPONENT_DONE) {			// detail des gegners			var detail:ChallengeDetail = ChallengeDetail(RemotingBeanCaster.getCastedInstance(new ChallengeDetail(), re.result["details"][ChallengeDetail.MODE_OPPONENT]));			// user in detail speichern			detail.setUser(User(RemotingBeanCaster.getCastedInstance(new User(), detail.getUser())));			// result in detail speichern			detail.setResult(Result(RemotingBeanCaster.getCastedInstance(new Result(), detail.getResult())));			// in challenge speichern			challenge.addDetail(ChallengeDetail.MODE_OPPONENT, detail);		}		// zurueck geben		return challenge;	}}