/*
 * Generated by ASDT
*/

import com.adgamewonderland.duden.sudoku.challenge.beans.Sudoku;
import com.adgamewonderland.duden.sudoku.game.beans.Container;
import com.adgamewonderland.duden.sudoku.game.beans.ContainerImpl;
import com.adgamewonderland.duden.sudoku.game.beans.Content;
import com.adgamewonderland.duden.sudoku.game.beans.Contentcounter;
import com.adgamewonderland.duden.sudoku.game.beans.Field;
import com.adgamewonderland.duden.sudoku.game.beans.FieldImpl;
import com.adgamewonderland.duden.sudoku.game.interfaces.IFieldListener;

import de.kruesch.event.EventBroadcaster;
import com.adgamewonderland.duden.sudoku.challenge.beans.Term;

class com.adgamewonderland.duden.sudoku.game.beans.Grid implements IFieldListener {

	private static var _instance:Grid;

	private static var EVENT_GRIDCHANGED:String = "onGridChanged";

	private static var EVENT_GRIDFINISHED:String = "onGridFinished";

	private var sudoku:Sudoku;

	private var term:Term;

	private var rows:Array;

	private var columns:Array;

	private var boxes:Array;

	private var contents:Array;

	private var fields:Array;

	private var contentcounter:Contentcounter;

	private var _event:EventBroadcaster;

	public static function getInstance():Grid {
		if (_instance == null)
			_instance = new Grid();
		return _instance;
	}

	public function initGrid(sudoku:Sudoku, term:Term ):Boolean
	{
		// sudoku speichern
		setSudoku(sudoku);
		// term speichern
		setTerm(term);
		// solutions: korrekte ziffern, die der spieler finden muss
		var solutions:Array = getSudoku().getSolutions().split("");
		// starters: felder, die zu beginn des spiels besetzt sind
		var starters:Array = getSudoku().getStarters().split("");
		// zeileninhalt
		var row:ContainerImpl;
		// spalteninhalt
		var column:ContainerImpl;
		// boxinhalt
		var box:ContainerImpl;
		// contentinhalt
		var content:ContainerImpl;
		// aktuelle solution
		var solution:Number;
		// aktueller character
		var character:String;

		// schleife ueber alle ziffern
		for (var i:Number = 0; i < solutions.length; i++) {
			// aktuelle solution
			solution = Number(solutions[i]);
			// aktueller character
			character = getCharacter(solution);
			// neues feld
			var field:FieldImpl = new FieldImpl();
			// id
			field.setId(i);
			// als listener registrieren
			field.addListener(this);
			// ziffer, die der spieler finden muss
			field.setSolution(new Content(solution, character));
			// unterscheidung, ob feld zu beginn des spiels gesetzt
			switch (starters[i] == 1) {
				// ja
				case true :
					// aktueller inhalt des felds
					field.setContent(new Content(solution, character));
					// nicht editierbar
					field.setEditable(false);
					// geloest
					field.setSolved(true);

					break;
				// nein
				case false :
					// leerer inhalt des felds
					field.setContent(new Content(Content.CONTENT_EMPTY, ""));
					// editierbar
					field.setEditable(true);
					// nicht geloest
					field.setSolved(false);

					break;
			}
			// speichern
			this.fields[i] = field;

			// testen, ob neuer content
			if (this.contents[solution - 1] == undefined) {
				// neuer contentcontainer
				content = new ContainerImpl();
				// typ setzen
				content.setType(Container.TYPE_CONTENT);
				// id setzen
				content.setId(solution - 1);
				// speichern
				this.contents[solution - 1] = content;
			} else {
				// aktueller contentcontainer
				content = this.contents[solution - 1];
			}
			// field in contentcontainer speichern
			content.addField(field);

			// testen, ob neue zeile
			if (this.rows.length == getRowNumber(field)) {
				// neuer zeilencontainer
				row = new ContainerImpl();
				// typ setzen
				row.setType(Container.TYPE_ROW);
				// id setzen
				row.setId(getRowNumber(field));
				// speichern
				this.rows.push(row);
			} else {
				// aktueller zeilencontainer
				row = this.rows[getRowNumber(field)];
			}
			// field in zeilencontainer speichern
			row.addField(field);

			// testen, ob neue spalte
			if (this.columns.length == getColumnNumber(field)) {
				// neuer spaltencontainer
				column = new ContainerImpl();
				// typ setzen
				column.setType(Container.TYPE_COLUMN);
				// id setzen
				column.setId(getColumnNumber(field));
				// speichern
				this.columns.push(column);
			} else {
				// aktueller spaltencontainer
				column = this.columns[getColumnNumber(field)];
			}
			// field in spaltencontainer speichern
			column.addField(field);

			// testen, ob neue box
			if (this.boxes.length == getBoxNumber(field)) {
				// neuer boxcontainer
				box = new ContainerImpl();
				// typ setzen
				box.setType(Container.TYPE_BOX);
				// id setzen
				box.setId(getBoxNumber(field));
				// speichern
				this.boxes.push(box);
			} else {
				// aktueller boxcontainer
				box = this.boxes[getBoxNumber(field)];
			}
			// field in boxcontainer speichern
			box.addField(field);
		}
		// anzahl der contents initialisieren
		initContentcounts();
		// erfolgreich
		return true;
	}

	public function getRowNumber(field:Field ):Number
	{
		// zeilennummer
		var rownum:Number = -1;
		// id des fields
		var id:Number = field.getId();
		// aus id berechnen
		rownum = Math.floor(id / 9);
		// zurueck geben
		return rownum;
	}

	public function getColumnNumber(field:Field ):Number
	{
		// spaltennummer
		var columnnum:Number = -1;
		// id des fields
		var id:Number = field.getId();
		// aus id berechnen
		columnnum = id % 9;
		// zurueck geben
		return columnnum;
	}

	public function getBoxNumber(field:Field ):Number
	{
		// boxnummer
		var boxnum:Number = -1;
		// zeilennummer
		var rownum:Number = getRowNumber(field);
		// spaltennummer
		var columnnum:Number = getColumnNumber(field);
		// boxnummer berechnen
		boxnum = (3 * Math.floor(rownum / 3) + Math.floor(columnnum / 3));
		// zurueck geben
		return boxnum;
	}

	public function onContentChanged(field:Field, oldcontent:Content ):Void
	{
		// drei faelle
		// 1. vorher leer => nachher gefuellt
		// 2. vorher gefuellt => nachhher leer
		// 3. vorher gefuellt => nachher gefuellt
		// hinzugefuegt
		if (oldcontent.getId() == Content.CONTENT_EMPTY) {
			// neuen content hochzaehlen
			if (field.getSolved()) this.contentcounter.count(field.getContent(), Contentcounter.UP);
		// geloescht
		} else if (field.getContent().getId() == Content.CONTENT_EMPTY) {
			// alten content runter zaehlen
			if (field.getSolution().equals(oldcontent)) this.contentcounter.count(oldcontent, Contentcounter.DOWN);
		// geaendert
		} else {
			// neuen content hochzaehlen
			if (field.getSolved()) this.contentcounter.count(field.getContent(), Contentcounter.UP);
			// alten content runter zaehlen
			if (field.getSolution().equals(oldcontent)) this.contentcounter.count(oldcontent, Contentcounter.DOWN);
		}
		// listener informieren
		_event.send(EVENT_GRIDCHANGED, field);
		// testen, ob spiel erfolgreich beendet
		if (this.contentcounter.isFinished()) _event.send(EVENT_GRIDFINISHED);
	}

	public function onGuessChanged(field:Field, guess:Content, added:Boolean ):Void
	{
	}

	public function onContainerFinished(container:ContainerImpl ):Void
	{
	}

	private function initContentcounts():Void
	{
		// schleife ueber contentcontainer
		for (var i:String in contents) {
			// aktueller contentcontainer
			var container:ContainerImpl = contents[i];
			// solution
			var solution:Content = FieldImpl(container.getFields()[0]).getSolution();
			// anzahl korrekt ausgefuellter fields
			var numfieldssolved:Number = container.getNumFieldsSolved();
			// anzahl speichern
			this.contentcounter.count(solution, numfieldssolved);
		}
	}

	public function getCharacter(solution:Number ):String
	{
		// characters: buchstaben des loesungsworts
		var characters:Array = getTerm().getText().split("");
		// character der uebergebenen solution
		var character = String(characters[solution - 1]);
		// zuruck geben
		return character;
	}

	public function solveSudoku():Void
	{
		// aktuelles feld
		var field:FieldImpl;
		// counter
		var counter:Number = 0;
		// interval
		var interval:Number;
		// funktion zum loesen eines felds
		var doSolve:Function = function(fields:Array ):Void
		{
			// aktuelles feld
			field = fields[counter];
			// testen, ob editierbar
			if (field.getEditable()) {
				// content auf solution setzen
				field.changeContent(field.getSolution());
			}
			// hochzaehlen / abbrechen
			if (++counter == fields.length) clearInterval(interval);
		};
		// nach pause loesen
		interval = setInterval(doSolve, 200, this.fields);
	}

	public function addListener(l ):Void
	{
		_event.addListener(l);
	}

	public function removeListener(l ):Void
	{
		_event.removeListener(l);
	}

	public function getRows():Array {
		return rows;
	}

	public function setRows(rows:Array):Void {
		this.rows = rows;
	}

	public function getBoxes():Array {
		return boxes;
	}

	public function setBoxes(boxes:Array):Void {
		this.boxes = boxes;
	}

	public function getColumns():Array {
		return columns;
	}

	public function setColumns(columns:Array):Void {
		this.columns = columns;
	}

	public function getFields():Array {
		return fields;
	}

	public function setFields(fields:Array):Void {
		this.fields = fields;
	}

	public function getContents():Array {
		return contents;
	}

	public function setContents(contents:Array):Void {
		this.contents = contents;
	}

	public function getContentcounter():Contentcounter {
		return contentcounter;
	}

	public function setContentcounter(contentcounter:Contentcounter):Void {
		this.contentcounter = contentcounter;
	}

	public function getSudoku():Sudoku {
		return sudoku;
	}

	public function setSudoku(sudoku:Sudoku):Void {
		this.sudoku = sudoku;
	}

	public function setTerm(term:Term):Void {
		this.term = term;
	}

	public function getTerm():Term {
		return this.term;
	}

	public function reset():Void
	{
		delete _event;
		delete contentcounter;
		delete contents;
		delete fields;
		delete boxes;
		delete columns;
		delete rows;
		delete term;
		delete sudoku;
		delete _instance;
	}

	private function Grid() {
		sudoku = null;
		term = null;
		rows = new Array();
		columns = new Array();
		boxes = new Array();
		fields = new Array();
		contents = new Array();
		contentcounter = new Contentcounter();
		_event = new EventBroadcaster();
	}

}