import com.adgamewonderland.eplus.baseclip.ui.MenuItemUI;import com.adgamewonderland.eplus.baseclip.interfaces.Fadable;import com.adgamewonderland.agw.math.Point;import com.adgamewonderland.eplus.baseclip.util.Fader;import com.adgamewonderland.eplus.baseclip.ui.MenuItemSubUI;import com.adgamewonderland.eplus.baseclip.descriptors.NavigationDescriptor;import com.adgamewonderland.eplus.baseclip.ui.ContentUI;import com.adgamewonderland.eplus.baseclip.ui.NavigationUI;/*klasse:			MenuItemMainUIautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			epluserstellung: 		25.02.2005zuletzt bearbeitet:	09.03.2005durch			gjstatus:			final*/class com.adgamewonderland.eplus.baseclip.ui.MenuItemMainUI extends MenuItemUI implements Fadable {	private static var SUBMENUPOS:Object = {x : 16, y : 32};	private static var SUBMENUYDIFF:Number = 20;	private static var TEXTCOLORS:Array = [0x000000, 0xFFFFFF];	private static var INITTIME:Number = 400;	private static var FADETIME:Number = 250;	private static var FADESTEPS:Number = 5;	private static var MOVETIME:Number = 250;	private var _myIndex:Number;	private var _myPosSitemap:Object;	private var myPosSitemap:Point;	private var mySubMenuItems:Object;	private var mySubPath:Array;	private var isSubActive:Boolean;	private var isSitemap:Boolean;	private var myFader:Fader;	private var myInterval:Number;	private var submenu_mc:MovieClip;	public function MenuItemMainUI()	{		// eigenschaften des MenuItemUI		super();		// x-abstand zur ausklappposition		myXdiff = XDIFF["main"];		// bei navigation registrieren		NavigationUI.getMovieClip().registerMainMenuItem(_myPath, this);		// sitemap position auf buehne aus komponentenparametern		myPosSitemap = new Point(_myPosSitemap.x, _myPosSitemap.y);		// assoziatives array fuer submenu initialisieren		mySubMenuItems = initSubMenu();		// pfad zum submenue fuer deep-linking		mySubPath = [];		// ist das submenue aktiv		isSubActive = false;		// wurde zuletzt zu sitemap bewegt		isSitemap = false;		// fader		myFader = new Fader(this);		// ausblenden		_visible = false;		// nach pause einfaden		myInterval = setInterval(this, "initItem", (_myIndex - 1) * INITTIME);	}	public function get submenupos():Object	{		// position des submenus		return SUBMENUPOS;	}	public function set subpath(path:Array ):Void	{		// pfad zum submenue fuer deep-linking		mySubPath = path;	}	public function get subpath():Array	{		// pfad zum submenue fuer deep-linking		return mySubPath;	}	public function set sitemap(bool:Boolean ):Void	{		// wurde zuletzt zu sitemap bewegt		isSitemap = bool;	}	public function get sitemap():Boolean	{		// wurde zuletzt zu sitemap bewegt		return isSitemap;	}	public function onRollOver()	{		// leicht verschieben		_y -= 1;		// animation abspielen		animation_mc.gotoAndPlay("frOver");		// text faerben		var col:Color = new Color(menuname_mc);		col.setRGB(TEXTCOLORS[1]);	}	public function onRollOut()	{		// leicht verschieben		_y += 1;		// animation abspielen		animation_mc.gotoAndPlay("frOut");		// text faerben		var col:Color = new Color(menuname_mc);		col.setRGB(TEXTCOLORS[0]);	}	public function onPress()	{		// mausverfolgung starten		trackMouse(true);	}	public function onRelease()	{		// abbrechen, wenn aktuell in bewegung		if (moving == true) return;		// aktuell vom user aktiviert oder nicht		switch (activated) {			// ja => content oder submenue ein- / ausblenden			case true :				// ggf. content anzeigen				if (isSubActive && myContentDescriptor.hascontent == true) { //  && sitemap == false					// submenue resetten					resetSubMenu(null);					// content anzeigen//					ContentUI.getMovieClip().showContent(myContentDescriptor);					// an hauptnavigation weiter reichen					NavigationUI.getMovieClip().swapMenu(myContentDescriptor.path);				} else {					// ein- / ausblenden					showSubMenu(!isSubActive);				}				break;			// nein => hauptnavigation umschalten			case false :				// an hauptnavigation weiter reichen				NavigationUI.getMovieClip().swapMenu(myContentDescriptor.path);				break;		}	}	public function onReleaseOutside()	{		// animation und textfarbe aendern		onRollOut();	}	public function onMove():Void	{		// submenu ausblenden		if (moving == false) showSubMenu(false);		// aktuell in bewegung		moving = true;		// button ausschalten		enabled = false;	}	public function onStopMove():Void	{		// art der beendeten bewegung		var lastmove:String = movemode;		// bewegung beendet		movemode = "";		// nicht in bewegung		moving = false;		// button einschalten		enabled = true;		// submenu positionieren		setSubMenuPos();		// je nach art der beendeten bewegung		switch (lastmove) {			// an startposition angekommen			case "start" :				// nicht an sitemap position				sitemap = false;				// navigation informieren, damit content eingeblendet werden kann				NavigationUI.getMovieClip().onItemStart();				break;			// an ein- / ausklappposition angekommen			case "activated" :				// nicht an sitemap position				sitemap = false;				// angekommen				onReachTargetPos();			// an dragposition angekommen			case "drag" :				// draggen endet erst onMouseUp => nichts weiter veranlassen				break;			// an sitemapposition angekommen			case "sitemap" :				// angekommen				onReachSitemapPos();				break;			// unbekannt			default :				break;		}	}	public function moveToActivated(bool:Boolean ):Void	{		// abbrechen, wenn schon an dieser position		if (sitemap == false && activated == bool && dragged == false && subpath.length <= 1) return;		// testen ob deep-linking		if (activated && subpath.length > 1) {			// deep-link anzeiegn			showDeepLink();			// abbrechen			return;		}		// aktuell vom user aktiviert		activated = bool;		// art der bewegung		movemode = "activated";		// wurde zuletzt nicht gedraggt		dragged = false;		// daempfung der hoehe bei kreisbewegung		var att:Number = 0.5;		// zur ausklapp- / einklappposition		switch (bool) {			// ausklapp			case true :				// ganz nach vorne				swapDepths(1000);				// bewegung starten (kreisfoermig, richtung nach oben)//				myMover.startMove(2, new Point(myPosAct.x, myPosAct.y), new Point(myPosStart.x + myXdiff, myPosStart.y), MOVETIME, {direction : -1 * att});				// bewegung starten (linear)				myMover.startMove(0, new Point(myPosAct.x, myPosAct.y), new Point(myPosStart.x + myXdiff, myPosStart.y), MOVETIME, {});				break;			// einklapp			case false :				// submenu ausblenden				showSubMenu(false);				// submenu resetten				resetSubMenu(null);				// bewegung starten (kreisfoermig, richtung nach unten)//				myMover.startMove(2, new Point(myPosAct.x, myPosAct.y), myPosStart, MOVETIME, {direction : 1 * att});				// bewegung starten (linear)				myMover.startMove(0, new Point(myPosAct.x, myPosAct.y), myPosStart, MOVETIME, {});				break;		}	}	public function onReachTargetPos():Void	{		// aktuell vom user aktiviert oder nicht		switch (activated) {			// ja => submenue und content einblenden			case true :				// animation und textfarbe aendern				onRollOut();				// submenu einblenden				showSubMenu(true);				// testen ob deep-linking				switch (subpath.length > 1) {					// deep-linking					case true :						// deep-link anzeiegn						showDeepLink();						break;					// normal					case false :						// ggf. content anzeigen						if (myContentDescriptor.hascontent == true) ContentUI.getMovieClip().showContent(myContentDescriptor);						break;				}				// submenu einblenden//				showSubMenu(true);				break;			// nein => nichts			case false :				break;		}	}	public function moveToSitemap():Void	{		// art der bewegung		movemode = "sitemap";		// submenu ausblenden		showSubMenu(false);		// bewegung starten (linear)		myMover.startMove(0, new Point(_x, _y), myPosSitemap, MOVETIME, {});	}	public function onReachSitemapPos():Void	{		// an sitemap position		sitemap = true;		// aktuell vom user aktiviert		activated = true;		// submenu einblenden		showSubMenu(true);	}	public function swapSubMenu(path:Array, clean:Boolean ):Void	{		// navigation aufraeumen		if (clean != false) NavigationUI.getMovieClip().swapMenu(myContentDescriptor.path);		// menuitem an uebergebenem pfad		var item:MenuItemSubUI = mySubMenuItems[path.join("")];		// alle anderen menupunkte an einklappposition		resetSubMenu(item);		// an ausklappposition		item.moveToActivated(true);	}	public function resetSubMenu(exclitem:MenuItemSubUI ):Void	{		// schleife ueber alle submenupunkte		for (var i:String in mySubMenuItems) {			// aktuelles item			var item:MenuItemSubUI = mySubMenuItems[i];			// ueberspringen, wenn an uebergebenem pfad			if (item === exclitem) continue;			// an einklapposition			item.moveToActivated(false);		}		// pfad fuer deep-linking resetten		subpath = [];	}	public function onFade(alpha:Number ):Void	{		// einblenden		_visible = true;		// alpha setzen		_alpha = alpha;	}	public function onStopFade():Void	{		// nach pause einfaden		myInterval = setInterval(this, "moveToStart", (6 - _myIndex) * INITTIME);	}	private function initItem():Void	{		// interval loeschen		clearInterval(myInterval);		// einfaden		myFader.startFader(0, 100, FADETIME, FADESTEPS);	}	private function moveToStart():Void	{		// interval loeschen		clearInterval(myInterval);		// art der bewegung		movemode = "start";		// bewegung starten (kreisfoermig, richtung nach oben)//		myMover.startMove(2, new Point(_x, _y), myPosStart, MOVETIME, {direction : 0.5});		// bewegung starten (linear)		myMover.startMove(0, new Point(_x, _y), myPosStart, _myIndex * MOVETIME / 5, {});	}	private function initSubMenu():Object	{		// assoziatives array mit submenu items		var submenuitems:Object = {};		// submenu muss ausserhalb von menuitemmain liegen, damit die submenupunkte als buttosn erkannt werden		submenu_mc = NavigationUI.getMovieClip().getSubmenu(this);		// submenu ausblenden		submenu_mc._visible = false;//		showSubMenu(false);		// pfade fuer jedes submenu item		var pathes:Array = NavigationDescriptor.getInstance().getMenuItemsSub(_myPath);		// schleife ueber alle zu erstellenden items		for (var i:Number = 0; i < pathes.length; i++) {			// x-position			var xpos:Number = SUBMENUPOS.x;			// y-position			var ypos:Number = SUBMENUPOS.y + i * SUBMENUYDIFF;			// constructor fuer neues submenu item			var constructor:Object = {_x : xpos, _y : ypos, _myPath : pathes[i], _myMenuItemMain : this, _myPosStart : {x : xpos, y : ypos}};			// auf buehne bringen			var item:MenuItemSubUI = MenuItemSubUI(submenu_mc.attachMovie("MenuItemSubUI", "submenuitem" + i + "_mc", i + 1, constructor));			// in array speichern			submenuitems[pathes[i].join("")] = item;		}		// zurueck geben		return submenuitems;	}	private function showSubMenu(bool:Boolean ):Void	{		// ein- / ausblenden		submenu_mc._visible = true;		// ist das submenue aktiv		isSubActive = bool;		// positionieren		setSubMenuPos();		// items bewegen		for (var i:String in mySubMenuItems) {			// aktuelles item			var item:MenuItemSubUI = mySubMenuItems[i];			// ein- / ausblenden			switch (bool) {				// einblenden				case true :					// an start position					item.moveToStart(sitemap);					break;				// ausblenden				case false :					// an 0 position					item.moveToZero();					break;			}		}	}	private function showDeepLink():Void	{		// submenuitem aktivieren		swapSubMenu(subpath, false);		// pfad fuer deep-linking resetten		subpath = [];	}	private function setSubMenuPos():Void	{		// positionieren		submenu_mc._x = _x;		submenu_mc._y = _y;		// anzeige updaten		updateAfterEvent();	}}