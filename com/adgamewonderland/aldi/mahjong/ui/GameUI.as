/*
 * Generated by ASDT
*/

import com.adgamewonderland.agw.interfaces.ITimeConsumer;
import com.adgamewonderland.agw.net.RemotingBeanCaster;
import com.adgamewonderland.agw.util.Timer;
import com.adgamewonderland.agw.util.XMLConnector;
import com.adgamewonderland.aldi.mahjong.raster.Raum;
import com.adgamewonderland.aldi.mahjong.raster.Stein;
import com.adgamewonderland.aldi.mahjong.raster.SteinGrafikPara;
import com.adgamewonderland.aldi.mahjong.ui.ClockUI;
import com.adgamewonderland.aldi.mahjong.ui.DisplayUI;
import com.adgamewonderland.aldi.mahjong.ui.GameControllerUI;
import com.adgamewonderland.aldi.mahjong.ui.StoneUI;
import com.adgamewonderland.aldi.mahjong.util.GameConf;
import com.adgamewonderland.aldi.mahjong.util.RaumConf;

class com.adgamewonderland.aldi.mahjong.ui.GameUI extends MovieClip implements ITimeConsumer {

	private var myMotive:Array;

	private static var SCOREUP:Number = 10;

	private static var SCORETIME:Number = 5;

	private static var TIMEGAME:Number = 360;

	private static var TIMEPAIR:Number = 1;

	private static var TIMEHINT:Number = 10;

	private static var TIMESHUFFLE:Number = 20;

	private var layoutid:Number = 1;

	private var raum:Raum;

	private var gameconf:GameConf;

	private var stones:Array;

	private var pair:Array;

	private var score:Number;

	private var playground_mc:MovieClip;

	private var controller_mc:GameControllerUI;

	private var display_mc:DisplayUI;

	private var clock_mc:ClockUI;

	private var gametime:Timer;

	public function GameUI() {
		// initialisieren
		init();
	}

	public function init():Void
	{
		// haeufigkeit der motive, die ein stein haben kann
		myMotive = new Array(4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1);
		// raum, der die steine im raster verwaltet
		raum = new Raum();
		// spielkonfiguration bzgl. dimensionen
		gameconf = new GameConf();
		// steine auf dem spielfeld
		stones = new Array();
		// durch anklicken ausgewaehlte steine
		pair = new Array(null, null);
		// punktzahl
		score = 0;
		// spielfeld, auf das die steine attached werden
		playground_mc = createEmptyMovieClip("playground_mc", 1);
		// display
		display_mc = _parent.display_mc;
		// clock
		clock_mc = display_mc.getClock();
		// dauer des spiels
		gametime = new Timer();
		// controller ausblenden
		controller_mc._visible = false;
		// display resetten
		display_mc.showMoves(0);
		display_mc.showScore(0);
		display_mc.showStones(0);
		clock_mc.showTime(gametime);
	}

	public function loadLayout():Void
	{
		// xml-connector
		var conn:XMLConnector = new XMLConnector(this, _global.path + "aldi_mahjong2_layout" + getLayoutid() + ".xml");
		// laden
		conn.loadXML("onLayoutLoaded");
	}

	public function onLayoutLoaded(xmlobj:XML ):Void
	{
		// layout
		var layoutxml:XMLNode = xmlobj.firstChild;
		// gameconf
		var gameconfxml:XMLNode = layoutxml.firstChild;
		// als object
		var gameconfobj:Object = new XMLConnector(this, "").parseXMLNode(gameconfxml);
		// in bean casten
		setGameconf(GameConf(RemotingBeanCaster.getCastedInstance(new GameConf(), gameconfobj)));
		// aus xml loeschen
		layoutxml.firstChild.removeNode();

		// raumconf
		var raumconfxml:XMLNode = layoutxml.firstChild;
		// als object
		var raumconfobj:Object = new XMLConnector(this, "").parseXMLNode(raumconfxml);
		// in bean casten
		var raumconf:RaumConf = RaumConf(RemotingBeanCaster.getCastedInstance(new RaumConf(), raumconfobj));
		// belegung der ebenen parsen lassen
		raumconf.parseBelegung(raumconfxml.childNodes);

		// raum initialisieren
		initRaum(raumconf);
		// spielfeld initialisieren
		initPlayground();
		// spiel starten
		startGame();
	}

	public function startGame():Void
	{
		// controller einblenden
		controller_mc._visible = true;
		// punktzahl
		score = 0;
		// durch anklicken ausgewaehlte steine initialisieren
		initPair();
		// zeit initialisieren
		initTime();
		// anzeige updaten
		updateRound();
	}

	public function onTimeEnded():Void
	{
		// regulaer beenden
		stopGame(true);
	}

	public function stopGame(bool:Boolean ):Void
	{
		// uhr stoppen
		gametime.status = false;
		// punkte vergeben
		setScore(getScore() + gametime.getSeconds()["left"] * SCORETIME);
		// resetten
		resetGame();
		// je nach parameter
		if (bool) {
			// zur highscoreliste
			_root.highscore_mc.showGameover(getScore());
			// weiter auf hauptzeitleiste
			_root.gotoAndStop("frGameover");
		} else {
			// zur anleitung
			_root.gotoAndStop("frSplash");
		}
	}

	public function onSelectStone(mc:StoneUI ):Void
	{
		// tipp resetten
		resetHint();
		// liegt dieser stein frei
		var free:Boolean = getRaum().istSteinFrei(mc.getStone().getIdent());
		// wenn nicht frei
		if (!free) {
			// abbrechen
			return;
		}
		// erster ausgewaehlter stein
		var stone1:Stein = getPair()[0];
		// erster stein ausgewaehlt
		if (stone1 == null) {
			// sound abspielen
			_root.mcSound.spieleSound("stein1", 1);
			// stein auswaehlen
			mc.setSelected(true);
			// stein speichern
			getPair()[0] = mc.getStone();
		// zweiter stein ausgewaehlt
		} else {
			// sound abspielen
			_root.mcSound.spieleSound("stein2", 1);
			// testen, ob selber stein zum zweiten mal ausgewaehlt
			if (stone1 == mc.getStone()) {
				// stein abwaehlen
				mc.setSelected(false);
				// resetten
				initPair();
				// abbrechen
				return;
			} else {
				// stein auswaehlen
				mc.setSelected(true);
				// stein speichern
				getPair()[1] = mc.getStone();
				// testen, ob gueltiges paar
				checkPair();
			}
		}
	}

	public function showHint():Void
	{
		// resetten
		resetHint();
		// spielbares paar
		var steine:Array = getRaum().getSpielzug();
		// schleife ueber alle steine
		for (var j:String in steine) {
			// aktueller stein
			var stein:Stein = steine[j];
			// auswaehlen
			stein.getStoneui().setSelected(true);
		}
		// zeit abziehen
		gametime.addTime(TIMEHINT);
	}

	public function shuffleStones():Void
	{
		// alle gesetzten steine
		var steine:Array = getRaum().getGesetzeSteine();
		// motive der steine
		var motifs:Array = new Array();
		// schleife ueber alle steine
		for (var i:String in steine) {
			// aktueller stein
			var stein:Stein = steine[i];
			// motif speichern
			motifs.push(stein.getMotifid());
		}
		// zufaellig mischen
		var rand:Function = function(e1, e2) {
			return (Math.random() < 0.5 ? -1 : 1);
		};
		motifs.sort(rand);
		// schleife ueber alle steine
		for (var j:Number = 0; j < steine.length; j++) {
			// aktueller stein
			stein = steine[j];
			// motif aendern
			stein.setMotifid(motifs[j]);
			// und anzeigen lassen
			stein.getStoneui().setMotif(motifs[j]);
		}
		// zeit abziehen
		gametime.addTime(TIMESHUFFLE);
		// anzeige updaten
		updateRound();
	}

	public function pauseGame(bool:Boolean ):Void
	{
		// alle steine
		var steine:Array = getRaum().getSteine();
		// schleife ueber alle steine
		for (var j:String in steine) {
			// aktueller stein
			var stein:Stein = steine[j];
			// auf- / abdecken
			stein.getStoneui().setHidden(bool);
		}
		// zeit starten / stoppen
		gametime.status = !bool;
	}

	public function restartGame():Void
	{
		// beenden und zur anleitung
		stopGame(false);
	}

	public function getLayoutid():Number {
		return layoutid;
	}

	public function setLayoutid(layoutid:Number):Void {
		this.layoutid = layoutid;
	}

	public function getRaum():Raum {
		return raum;
	}

	public function getPair():Array {
		return pair;
	}

	public function setPair(pair:Array):Void {
		this.pair = pair;
	}

	public function getScore():Number {
		return score;
	}

	public function setScore(score:Number):Void {
		this.score = score;
	}

	private function initRaum(conf:RaumConf ):Void
	{
		// raum initialisieren
		getRaum().createRaum(conf);
	}

	private function initPlayground():Void
	{
		// spielfeld initialisieren
		var steine:Array = getRaum().getSteine();
		// schleife ueber alle steine
		for (var i:Number = 0; i < steine.length; i++) {
			// aktueller stein
			var stein:Stein = steine[i];
			// motif
			var motif:Number = getRandomMotif();
			// im stein speichern
			stein.setMotifid(motif);
			// auf buehne bringen
			var mc:StoneUI = initStone(stein);
			// im array speichern
			stones.push(mc);
			// im stein speichern
			stein.setStoneui(mc);
			// sonderbehandlung fuer vier einzelne steine
			if (stein.getMotifid() >= 36) stein.setMotifid(36);
		}
	}

	private function initStone(stein:Stein ):StoneUI
	{
		// infos ueber zeile, spalte, ebene
		var grafikpara:SteinGrafikPara = stein.getGrafikPara();
		// position
		var xpos:Number = grafikpara.getSpalte() * getGameconf().getBreite() * 0.5 + grafikpara.getEbene() * getGameconf().getXversatz() + getGameconf().getXpos();
		var ypos:Number = grafikpara.getZeile() * getGameconf().getHoehe() * 0.5 + grafikpara.getEbene() * getGameconf().getYversatz() + getGameconf().getYpos();
		// depth
		var depth:Number = stein.getIdent();
		// init-parameter
		var initobj:Object = {_x : xpos, _y : ypos, stone : stein, motif : stein.getMotifid(), game : this};
		// attachen
		var mc:MovieClip = (playground_mc.attachMovie("StoneUI", "stone" + depth + "_mc", depth, initobj));
		// zurueck geben
		return StoneUI(mc);
	}

	private function getRandomMotif():Number
	{
		// default kein stein / motiv
		var motiv:Number = -1;
		// schleife, um per zufall eines der motive auszusuchen
		var gefunden = false;
		do {
			// per zufall eines des array-elemente nehmen
			motiv = Math.floor(Math.random() * this.myMotive.length);
			// dieses motiv darf genommen werden, wenn noch nicht alle instanzen verbraucht
			if (--this.myMotive[motiv] >= 0) gefunden = true;
		} while (gefunden == false);
		// motiv um eines erhoehen, um verwirrung bzgl. namen / array auszuschliessen
		motiv ++;
		// zurueck geben
		return motiv;
	}

	private function initPair():Void
	{
		// durch anklicken ausgewaehlte steine
		pair = new Array(null, null);
	}

	private function checkPair():Void
	{
		// erster stein
		var stone1:Stein = getPair()[0];
		// zweiter stein
		var stone2:Stein = getPair()[1];
		// testen, ob paar
		if (stone1.checkPaar(stone2)) {
			// sound abspielen
			_root.mcSound.spieleSound("paar", 1);
			// punkte vergeben
			setScore(getScore() + SCOREUP);
			// zeitbonus vergeben
			gametime.addTime(TIMEPAIR);
			// steine wegraeumen
			getRaum().removeSteine(getPair());
			// anzeige updaten
			updateRound();

//			traceFreeStones();

		} else {
			// steine abwaehlen
			stone1.getStoneui().setSelected(false);
			stone2.getStoneui().setSelected(false);
		}
		// resetten
		initPair();
	}

	private function initTime():Void
	{
		// bei uhr anmelden
		gametime.addConsumer(this);
		// movieclip der uhr anmelden
		gametime.addUI(clock_mc);
		// dauer in sekunden uebergeben
		gametime.startTime(TIMEGAME);
		// uhr starten
		gametime.status = true;
	}

	private function updateRound():Void
	{
		// anzahl punkte anzeigen
		display_mc.showScore(getScore());
		// anzahl spielzuege
		var moves:Number = getRaum().getAnzahlSpielzuege();
		// anzeigen
		display_mc.showMoves(moves);
		// anzahl steine
		var stones:Number = getRaum().getSteinCount();
		// anzeigen
		display_mc.showStones(stones);

		// spiel beenden, wenn keine spielzuege oder steine mehr
		if (moves == 0 || stones == 0) stopGame(true);
	}

	private function resetHint():Void
	{
		// alle steine (01.01. gj: alle freien steine dauert eine sekunde!!!)
		var steine:Array = getRaum().getSteine();
		// schleife ueber steine
		for (var i:Number = 0; i < steine.length; i++) {
			// aktueller stein
			var stein:Stein = steine[i];
			// abwaehlen
			stein.getStoneui().setSelected(false);
		}
	}

	private function resetGame():Void
	{
		// controller ausblenden
		controller_mc._visible = false;
		// alle steine
		var steine:Array = getRaum().getSteine();
		// loeschen
		getRaum().removeSteine(steine);
		// raum initialisieren
		getRaum().init();
	}

	private function traceFreeStones():Void
	{
		var free:Array = getRaum().getAlleFreienSteine();
		for (var j : String in free) {
			var stein:Stein = free[j];
			stein.getStoneui().setSelected(true);
		}
	}

	public function getGameconf():GameConf {
		return gameconf;
	}

	public function setGameconf(gameconf:GameConf):Void {
		this.gameconf = gameconf;
	}

}