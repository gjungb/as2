/* 
 * Generated by ASDT 
*/ 

import com.adgamewonderland.aldi.sudoku.beans.Container;
import com.adgamewonderland.aldi.sudoku.beans.ContainerImpl;
import com.adgamewonderland.aldi.sudoku.beans.Content;
import com.adgamewonderland.aldi.sudoku.beans.Contentcounter;
import com.adgamewonderland.aldi.sudoku.beans.Field;
import com.adgamewonderland.aldi.sudoku.beans.FieldImpl;
import com.adgamewonderland.aldi.sudoku.beans.Solution;
import com.adgamewonderland.aldi.sudoku.interfaces.IFieldListener;

import de.kruesch.event.EventBroadcaster;

class com.adgamewonderland.aldi.sudoku.beans.Grid implements IFieldListener {
	
	private static var _instance:Grid;
	
	private static var EVENT_GRIDCHANGED:String = "onGridChanged";
	
	private static var EVENT_GRIDFINISHED:String = "onGridFinished";
	
	private var solution:Solution;
	
	private var rows:Array;
	
	private var columns:Array;
	
	private var boxes:Array;
	
	private var contents:Array;
	
	private var fields:Array;
	
	private var contentcounter:Contentcounter;
	
	private var _event:EventBroadcaster;
	
	public static function getInstance():Grid {
		if (_instance == null)
			_instance = new Grid();
		return _instance;
	}
	
	public function initGrid(solution:Solution ):Boolean
	{
		// speichern
		setSolution(solution);
		// solutions: korrekte ziffern, die der spieler finden muss
		var solutions:Array = getSolution().getSolutions().split("");
		// starters: felder, die zu beginn des spiels besetzt sind
		var starters:Array = getSolution().getStarters().split("");
		// zeileninhalt
		var row:ContainerImpl;
		// spalteninhalt
		var column:ContainerImpl;
		// boxinhalt
		var box:ContainerImpl;
		// contentinhalt
		var content:ContainerImpl;
		
		// schleife ueber alle ziffern
		for (var i:Number = 0; i < solutions.length; i++) {
			// neues feld
			var field:FieldImpl = new FieldImpl();
			// id
			field.setId(i);
			// als listener registrieren
			field.addListener(this);
			// ziffer, die der spieler finden muss
			field.setSolution(new Content(solutions[i]));
			// unterscheidung, ob feld zu beginn des spiels gesetzt
			switch (starters[i] == 1) {
				// ja
				case true :
					// aktueller inhalt des felds
					field.setContent(new Content(solutions[i]));
					// nicht editierbar
					field.setEditable(false);
					// geloest
					field.setSolved(true);
				
					break;
				// nein
				case false :
					// leerer inhalt des felds
					field.setContent(new Content(Content.CONTENT_EMPTY));
					// editierbar
					field.setEditable(true);
					// nicht geloest
					field.setSolved(false);
				
					break;
			}
			// speichern
			this.fields[i] = field;
			
			// testen, ob neuer content
			if (this.contents[solutions[i] - 1] == undefined) {
				// neuer contentcontainer
				content = new ContainerImpl();
				// typ setzen
				content.setType(Container.TYPE_CONTENT);
				// id setzen
				content.setId(solutions[i] - 1);
				// speichern
				this.contents[solutions[i] - 1] = content;
			} else {
				// aktueller contentcontainer
				content = this.contents[solutions[i] - 1];
			}
			// field in contentcontainer speichern
			content.addField(field);
			
			// testen, ob neue zeile
			if (this.rows.length == getRowNumber(field)) {
				// neuer zeilencontainer
				row = new ContainerImpl();
				// typ setzen
				row.setType(Container.TYPE_ROW);
				// id setzen
				row.setId(getRowNumber(field));
				// speichern
				this.rows.push(row);
			} else {
				// aktueller zeilencontainer
				row = this.rows[getRowNumber(field)];
			}
			// field in zeilencontainer speichern
			row.addField(field);
			
			// testen, ob neue spalte
			if (this.columns.length == getColumnNumber(field)) {
				// neuer spaltencontainer
				column = new ContainerImpl();
				// typ setzen
				column.setType(Container.TYPE_COLUMN);
				// id setzen
				column.setId(getColumnNumber(field));
				// speichern
				this.columns.push(column);
			} else {
				// aktueller spaltencontainer
				column = this.columns[getColumnNumber(field)];
			}
			// field in spaltencontainer speichern
			column.addField(field);

			// testen, ob neue box
			if (this.boxes.length == getBoxNumber(field)) {
				// neuer boxcontainer
				box = new ContainerImpl();
				// typ setzen
				box.setType(Container.TYPE_BOX);
				// id setzen
				box.setId(getBoxNumber(field));
				// speichern
				this.boxes.push(box);
			} else {
				// aktueller boxcontainer
				box = this.boxes[getBoxNumber(field)];
			}
			// field in boxcontainer speichern
			box.addField(field);
		}
		// anzahl der contents initialisieren
		initContentcounts();
		// erfolgreich
		return true;	
	}
	
	public function getRowNumber(field:Field ):Number
	{
		// zeilennummer
		var rownum:Number = -1;
		// id des fields
		var id:Number = field.getId();
		// aus id berechnen
		rownum = Math.floor(id / 9);
		// zurueck geben
		return rownum;
	}
	
	public function getColumnNumber(field:Field ):Number
	{
		// spaltennummer
		var columnnum:Number = -1;
		// id des fields
		var id:Number = field.getId();
		// aus id berechnen
		columnnum = id % 9;
		// zurueck geben
		return columnnum;
	}
	
	public function getBoxNumber(field:Field ):Number
	{
		// boxnummer
		var boxnum:Number = -1;
		// zeilennummer
		var rownum:Number = getRowNumber(field);
		// spaltennummer
		var columnnum:Number = getColumnNumber(field);
		// boxnummer berechnen
		boxnum = (3 * Math.floor(rownum / 3) + Math.floor(columnnum / 3));
		// zurueck geben
		return boxnum;
	}
	
	public function onContentChanged(field:Field, oldcontent:Content ):Void
	{
		// drei faelle
		// 1. vorher leer => nachher gefuellt
		// 2. vorher gefuellt => nachhher leer
		// 3. vorher gefuellt => nachher gefuellt
		// hinzugefuegt
		if (oldcontent.getId() == Content.CONTENT_EMPTY) {
			// neuen content hochzaehlen
			if (field.getSolved()) this.contentcounter.count(field.getContent(), Contentcounter.UP);
		// geloescht
		} else if (field.getContent().getId() == Content.CONTENT_EMPTY) {
			// alten content runter zaehlen
			if (field.getSolution().equals(oldcontent)) this.contentcounter.count(oldcontent, Contentcounter.DOWN);
		// geaendert
		} else {
			// neuen content hochzaehlen
			if (field.getSolved()) this.contentcounter.count(field.getContent(), Contentcounter.UP);
			// alten content runter zaehlen
			if (field.getSolution().equals(oldcontent)) this.contentcounter.count(oldcontent, Contentcounter.DOWN);
		}
		// listener informieren
		_event.send(EVENT_GRIDCHANGED, field);
		// testen, ob spiel erfolgreich beendet
		if (this.contentcounter.isFinished()) _event.send(EVENT_GRIDFINISHED);
	}
	
	public function onGuessChanged(field:Field, guess:Content, added:Boolean ):Void
	{
	}
	
	public function onContainerFinished(container:ContainerImpl ):Void
	{
	}
	
	private function initContentcounts():Void
	{
		// schleife ueber contentcontainer
		for (var i:String in contents) {
			// aktueller contentcontainer
			var container:ContainerImpl = contents[i];
			// solution
			var solution:Content = FieldImpl(container.getFields()[0]).getSolution();
			// anzahl korrekt ausgefuellter fields
			var numfieldssolved:Number = container.getNumFieldsSolved();
			// anzahl speichern
			this.contentcounter.count(solution, numfieldssolved);
		}
	}
	
	public function addListener(l ):Void
	{
		_event.addListener(l);
	}
	
	public function removeListener(l ):Void
	{
		_event.removeListener(l);
	}
	
	public function getRows():Array {
		return rows;
	}

	public function setRows(rows:Array):Void {
		this.rows = rows;
	}

	public function getBoxes():Array {
		return boxes;
	}

	public function setBoxes(boxes:Array):Void {
		this.boxes = boxes;
	}

	public function getColumns():Array {
		return columns;
	}

	public function setColumns(columns:Array):Void {
		this.columns = columns;
	}

	public function getFields():Array {
		return fields;
	}

	public function setFields(fields:Array):Void {
		this.fields = fields;
	}

	public function getContents():Array {
		return contents;
	}

	public function setContents(contents:Array):Void {
		this.contents = contents;
	}

	public function getContentcounter():Contentcounter {
		return contentcounter;
	}

	public function setContentcounter(contentcounter:Contentcounter):Void {
		this.contentcounter = contentcounter;
	}

	public function getSolution():Solution {
		return solution;
	}

	public function setSolution(solution:Solution):Void {
		this.solution = solution;
	}
	
	public function reset():Void
	{
		delete _event;
		delete contentcounter;
		delete contents;
		delete fields;
		delete boxes;
		delete columns;
		delete rows;
		delete solution;
		delete _instance;
	}
	
	private function Grid() {
		solution = null;
		rows = new Array();
		columns = new Array();
		boxes = new Array();
		fields = new Array();
		contents = new Array();
		contentcounter = new Contentcounter();
		_event = new EventBroadcaster();
	}

}