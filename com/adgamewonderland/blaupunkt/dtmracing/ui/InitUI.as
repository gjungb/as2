/*  * Generated by ASDT */ /*klasse:			InitUIautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			blaupunkterstellung: 		22.06.2005zuletzt bearbeitet:	22.06.2005durch			gjstatus:			in bearbeitung*/import mx.rpc.ResultEvent;import mx.rpc.FaultEvent;import com.adgamewonderland.agw.*;import com.adgamewonderland.agw.net.*;import com.adgamewonderland.agw.util.*;import com.adgamewonderland.blaupunkt.dtmracing.challenge.*;import com.adgamewonderland.blaupunkt.dtmracing.remoting.*;import com.adgamewonderland.blaupunkt.dtmracing.ui.*;class com.adgamewonderland.blaupunkt.dtmracing.ui.InitUI extends MovieClip {		private static var STATE_MIN:Number = 0;		private static var STATE_MAX:Number = 3;		private var myDtmRacingUI:DtmRacingUI;		private var myState:Number = STATE_MIN;		private var myMailid:String;		private var myEmail:String;		private var loader_mc:MovieClip;		public function InitUI()	{		// hauptzeitleiste		myDtmRacingUI = DtmRacingUI(_parent);		// abspielen verfolgen		var follower:TimelineFollower = new TimelineFollower(this, "init");		// abspielen verfolgen		onEnterFrame = function() {			follower.followTimeline();		}		// loader ausblenden		loader_mc._visible = false;	}		public function init():Void	{		// mailid aus jsp		myMailid = _root.mailid;		// email aus jsp		myEmail = _root.email;				// loader einblenden		loader_mc._visible = true;		// text anzeigen		loader_mc.message_txt.text = "LOADING DATA";		// rennstrecken laden		loadTracks();		// fahrzeuge laden		loadCars();		// herausforderung laden		loadChallenge();	}		public function loadTracks():Void	{		// rennstrecken laden		StatisticConnector.loadTracks(this, "onTracksLoaded");	}		public function onTracksLoaded(re:ResultEvent ):Void	{		// speichern		ChallengeController.getInstance().setTracks(re.result);		// status updaten		updateState();		}		public function loadCars():Void	{		// fahrzeuge laden		StatisticConnector.loadCars(this, "onCarsLoaded");	}		public function onCarsLoaded(re:ResultEvent ):Void	{		// speichern		ChallengeController.getInstance().setCars(re.result);		// status updaten		updateState();		}		public function loadChallenge():Void	{		// testen, ob 32-stellige mailid		if (myMailid.length == 32) {			// challenge laden			ChallengeConnector.loadChallengeByMailid(myMailid, this, "onChallengeLoaded");					} else {			// status updaten			updateState();			}	}		public function onChallengeLoaded(re:ResultEvent ):Void	{		// in challenge casten		var challenge:Challenge = ChallengeController.getInstance().getCastedChallenge(re.result);		// abbrechen, wenn nicht korrekte challenge		if (challenge.getMailid() != myMailid) {			// status updaten			updateState();			// abbrechen			return;		}				// 1. ist der user, dessen email vom jsp uebergeben wurde, challenger oder opponent		var mode:Number;		// challenger		if (challenge.getDetails(ChallengeDetail.MODE_CHALLENGER).getEmail() == myEmail) mode = ChallengeDetail.MODE_CHALLENGER;		// opponent		if (challenge.getDetails(ChallengeDetail.MODE_OPPONENT).getEmail() == myEmail) mode = ChallengeDetail.MODE_OPPONENT;		// 2. je nach mode weiteres vorgehen		switch (mode) {			// challenger			case ChallengeDetail.MODE_CHALLENGER :				// abbrechen, wenn nicht beendete challenge				if (challenge.getStatus() < Challenge.STATUS_OPPONENT_DONE) {					// status updaten					updateState();					// abbrechen					return;				}				// speichern				ChallengeController.getInstance().setChallenge(challenge);				// nach login soll siegerehrung angezeigt werden				myDtmRacingUI.setNext(DtmRacingUI.NEXT_AWARD);				// status updaten				updateState();							break;			// opponent			case ChallengeDetail.MODE_OPPONENT :				// abbrechen, wenn beendete challenge				if (challenge.getStatus() >= Challenge.STATUS_OPPONENT_DONE) {					// status updaten					updateState();					// abbrechen					return;				}				// speichern				ChallengeController.getInstance().setChallenge(challenge);				// nach login soll challenge angezeigt werden				myDtmRacingUI.setNext(DtmRacingUI.NEXT_CHALLENGE);				// details ueber gegner laden lassen (war urspruenglich challenger)				ChallengeConnector.loadOpponent(challenge.getChallengerDetail().getEmail(), this, "onOpponentLoaded");							break;			// nix			default :				// nach login soll main angezeigt werden				myDtmRacingUI.setNext(DtmRacingUI.NEXT_MAIN);				// status updaten				updateState();		}	}		public function onOpponentLoaded(re:ResultEvent ):Void	{		// neuer gegner		var opponent:User = User(RemotingBeanCaster.getCastedInstance(new User(), re.result));		// gegner speichern		ChallengeController.getInstance().setOpponent(opponent);		// status updaten		updateState();	}		public function onInitFinished(next:Number ):Void	{		// zum login		myDtmRacingUI.showLogin();	}		public function onConnectorFault(fe:FaultEvent ):Void	{   		trace("There was a problem: " + fe.fault.faultstring);	   	trace("The faultcode is: " + fe.fault.faultcode);	 	trace("The detail: " + fe.fault.detail);	   	trace("The error class name is: " + fe.fault.type);	}		private function updateState():Void	{		// ladestatus hochzaehlen		myState++;		// testen, ob alles durch		if (myState == STATE_MAX) {			// loader ausblenden			loader_mc._visible = false;			// abspielen verfolgen			var follower:TimelineFollower = new TimelineFollower(this, "onInitFinished", DtmRacingUI.NEXT_LOGIN);			// abspielen verfolgen			onEnterFrame = function() {				follower.followTimeline();			}			// abspielen			gotoAndPlay("frClose");		}	}	} /* end class InitUI */