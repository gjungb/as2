/* Board** Generated from ArgoUML Model ** ActionScript 2 generator module provided by www.codealloy.com */ /*klasse:			Boardautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			zdferstellung: 		14.06.2004zuletzt bearbeitet:	28.06.2004durch			gjstatus:			in bearbeitung*/import com.adgamewonderland.zdf.buchstapler.*import com.adgamewonderland.agw.*class com.adgamewonderland.zdf.buchstapler.Board extends MovieClip {	// Attributes		private var _myXpos:Object;		private var _myYpos:Object;		private var myXpos:Object; // min, diff		private var myYpos:Object; // act		private var myBooks:Array;		private var myWord:String;		private var myCount:Object; // max, act		private var isAvailable:Boolean;		private var myPosition:Point;		// Operations		public  function Board()	{		// minimale x-position, x-abstand der buecher (aus komponentenparameter)		myXpos = _myXpos;		// y-position der buecher (aus komponentenparameter)		myYpos = _myYpos;		// buecher im regal		myBooks = [];		// aktuelles wort, das die buecher bilden		myWord = "";		// maximale / aktuelle anzahl der buecher		myCount = {max : 26, act : 0};		// duerfen buecher in dieses regal gestellt werden		isAvailable = true;		// position		myPosition = new Point (_x, _y);		// registrieren		_parent.registerBoard(this);	}		public  function initBoard():Void	{		// buecher im regal		books = [];		// aktuelles wort, das die buecher bilden		myWord = "";		// maximale / aktuelle anzahl der buecher		myCount = {max : 26, act : 0};		// duerfen buecher in dieses regal gestellt werden		available = true;	}		public  function set books(arr:Array ):Void	{		// buecher im regal		myBooks = arr;	}		public  function get books():Array	{		// zurueck geben		return (myBooks);	}		public  function get count():Object	{		// zurueck geben		return (myCount);	}		public  function set available(bool:Boolean ):Void	{		// duerfen buecher in dieses regal gestellt werden		isAvailable = bool;	}		public  function get available():Boolean	{		// zurueck geben		return (isAvailable);	}		public  function get position():Point	{		// zurueck geben		return (myPosition);	}		public  function addStartBook(index:Number, character:String ):Void	{		// position im board		var pos:Point = getPosByIndex(index);		// buchstabe// 		var character:String = String.fromCharCode(97 + index);		// neues buch		var book:Book = _global.Room.addBook(pos, this, character);		// auswaehlbar		book.selectable = true;		// einfuegen		insertBook(book);	}		public  function insertBook(book:Book ):Void	{		// index im array abhaengig von der x-position des buchs		var index:Number = getIndexByPos(book.position);		// testen, ob weiter rechts als aktuell ganz rechtes buch// 		if (index > myCount.act) index = myCount.act;		// neue position		var newpos:Object = {};		// x-position		newpos.x = myXpos.min + index * myXpos.diff + book.width / 2;		// y-position		newpos.y = myYpos.act;		// position in globale koordinaten		this.localToGlobal(newpos);		// positionieren		book._x = newpos.x;		book._y = newpos.y;		// position speichern		book.position = new Point(book._x, book._y);				// buecher neu sortieren		updateBooks("right", index, 1);		// neues buch in array		myBooks[index] = book;		// aktuelles wort, das die buecher bilden, updaten		updateWord();	}		public function removeBook(book:Book ):Void	{		// index im array abhaengig von der x-position des buchs		var index:Number = getIndexByPos(book.position);		// buecher neu sortieren		updateBooks("left", index, 1);		// array verkuerzen		myBooks.splice(-1);		// aktuelles wort, das die buecher bilden, updaten		updateWord();	}		private function updateBooks(dir:String, index:Number, count:Number ):Void	{		// je nach richtung		switch (dir) {			// nach rechts verschieben			case "right" :				// buecher rechts vom neuen buch nach rechts verschieben				for (var i:Number = myBooks.length - 1; i >= index; i--) {					// aktuelles buch					var book:Book = myBooks[i];					// im array nach rechts					myBooks[i + count] = book;					// auf buehne nach rechts					book._x += count * myXpos.diff;					// position speichern					book.position = new Point(book._x, book._y);				}				break;			// nach links verschieben			case "left" :				// buecher rechts vom bisherigen buch nach links verschieben				for (var i:Number = index + 1; i < myBooks.length; i++) {					// aktuelles buch					var book:Book = myBooks[i];					// im array nach links					myBooks[i - count] = book;					// auf buehne nach links					book._x -= count * myXpos.diff;					// position speichern					book.position = new Point(book._x, book._y);				}				break;		}	}		private function updateWord():Void	{		// zaehlen		myCount.act = myBooks.length;		// und ggf. sperren		available = (myCount.act < myCount.max);		// aktuelles wort		myWord = "";		// schleife ueber alle buecher		for (var i:Number = 0; i < myBooks.length; i ++) {			// buchstabe dieses buchs in wort schreiben			myWord += myBooks[i].character;		}		// testen, ob loesungswort gelegt		var solution:Object = _global.Room.checkSolution(myWord);		// falls korrekte loesung, 		if (solution.first != -1) {			// anzahl der buecher, die weg muessen			var count:Number = solution.last - solution.first;			// schleife ueber buecher, die weg muessen			for (var i:Number = 0; i < count; i ++) {				// aktuelles buch				var book:Book = myBooks[solution.first + i];				// unsichtbar				book._visible = false;			}			// wolke anzeigen lassen (ruft dann clearSolution auf)			_global.Room.showCloud(this, solution);		}	}		public function clearSolution(solution:Object ):Void	{		// anzahl der buecher, die weg muessen		var count:Number = solution.last - solution.first;		// schleife ueber buecher, die weg muessen		for (var i:Number = 0; i < count; i ++) {			// aktuelles buch			var book:Book = myBooks[solution.first + i];			// von buehne entfernen			book.removeMovieClip();		}		// buecher neu sortieren		updateBooks("left", solution.last - 1, count);		// array verkuerzen		myBooks.splice(-count);		// punkte zaehlen// 		_global.Room.countScore(solution.score);		_global.Room.score += solution.score;		// aktuelles wort, das die buecher bilden, updaten		updateWord();	}		public  function getIndexByPos(pos:Point ):Number	{		// object fuer koordinaten		var p:Object = {x : pos.x, y : pos.y};		// position in lokale koordinaten		this.globalToLocal(p);		// index errechnet sich aus der division der x-position und dem festgelegten x-abstand		var index:Number = Math.floor((p.x - myXpos.min) / myXpos.diff);		// testen, ob weiter rechts als aktuell ganz rechtes buch		if (index > myCount.act) index = myCount.act;		// nicht negativ		if (index < 0) index = 0;		// zurueck geben		return (index);	}		public function getPosByIndex(index:Number ):Point	{		// object fuer koordinaten		var p:Object = {x : 0, y : myYpos.act};		// x-position berechnet sich aus minimaler x-position und dem festgelegten x-abstand		p.x = myXpos.min + index * myXpos.diff;		// position in lokale koordinaten		this.localToGlobal(p);		// als punkt zurueck geben		return (new Point(p.x, p.y));	}} /* end class Board */