/* Stack** Generated from ArgoUML Model ** ActionScript 2 generator module provided by www.codealloy.com */ /*klasse:			Stackautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			zdferstellung: 		14.06.2004zuletzt bearbeitet:	06.07.2004durch			gjstatus:			in bearbeitung*/import com.adgamewonderland.zdf.buchstapler.*import com.adgamewonderland.agw.*class com.adgamewonderland.zdf.buchstapler.Stack extends MovieClip {	// Attributes		private var _myXpos:Object;		private var _myYpos:Object;		private var _myTime:Object;		private var _mySpeed:Number;		private var _myAcceleration:Number;		private var myXpos:Object;		private var myYpos:Object;		private var myTime:Object;		private var myBooks:Array;		private var myInterval:Number;		// Operations		public  function Stack()	{		// minimale und maximale x-position der buecher (aus komponentenparameter)		myXpos = _myXpos;		// aktuelle x-position des fallenden buchs		myXpos.act = myXpos.min;		// minimale und maximale y-position der buecher (aus komponentenparameter)		myYpos = _myYpos;		// aktuelle y-position des fallenden buchs		myYpos.act = myYpos.min;		// minimale, maximale zeit zwischen den fallenden buechern, anzahl der level, bis minimalzeit erreicht wird (aus komponentenparameter)		myTime = _myTime;		// aktuelle zeit zwischen den fallenden buechern		myTime.act = myTime.max;		// alle buecher (fallend und gefallen)		myBooks = new Array();		// interval zeiger		myInterval = 0;				// aenderungen des maximalen y-position der buecher ueberwachen, um vollen stapel zu bemerken		this.watch("ymax", onChangeYmax);	}		public function changeStack(cmd:String, book:Book ):Void	{		// je nach kommando		switch (cmd) {			// starten			case "start" :				// aktuelles level des spiels				var level:Number = _global.Room.level;				// pause bis zum naechsten buch				myTime.act = Math.round(myTime.max - (level - 1) * (myTime.max - myTime.min) / myTime.level);				// deckeln				if (level > myTime.level) myTime.act = myTime.min;				// erstes buch				changeStack("next");				// nach pause neues buch				myInterval = setInterval(this, "changeStack", myTime.act, "next");							break;			// naechstes buch			case "next" :				// x-position				myXpos.act = Math.round(myXpos.min + Math.random() * (myXpos.max - myXpos.min));				// y-position				myYpos.act = myYpos.min; // -20; // 				// position				var pos:Point = new Point(myXpos.act, myYpos.act);				// auf buehne und in array				_global.Room.addBook(pos, this, "");				// buecher zaehlen				_global.Room.countBook();							break;			// buch unten angekommen			case "add" :				// in array schreiben				myBooks.push(book);				// bisher oben liegendes buch nicht mehr auswaehlbar				myBooks[myBooks.length - 2].selectable = false;				// jetzt oben liegendes buch auswaehlbar, falls regal nicht voll				myBooks[myBooks.length - 1].selectable = _global.Room.isShelfFree();				// maximalposition um breite des buchs verringern				ymax -= myBooks[myBooks.length - 1].width;				// sound abspielen				_root.sound_mc.spieleSound("buchaufprall", 1);				break;			// buch vom stapel genommen			case "remove" :				// jetzt oben liegendes buch auswaehlbar				myBooks[myBooks.length - 2].selectable = true;				// maximalposition um breite des buchs erhoehen				ymax += myBooks[myBooks.length - 1].width;				// bisher oben liegendes buch aus array entfernen				myBooks.splice(-1);				break;			// pausieren			case "pause" :				// testen, ob buecher unterwegs (sprich interval aktiv)				if (typeof myInterval != "undefined") {					// keine weiteren buecher					clearInterval(myInterval);					// interval loeschen					delete(myInterval);					// alle buecher deaktivieren					for (var i in myBooks) myBooks[i].selectable = false;				} else {					// alle buecher aktivieren// 					for (var i in myBooks) myBooks[i].selectable = true;					// starten					changeStack("start");				}							break;			// blockieren			case "lock" :				// jetzt oben liegendes buch nicht mehr auswaehlbar				myBooks[myBooks.length - 1].selectable = false;				break;			// entblockieren			case "unlock" :				// jetzt oben liegendes buch auswaehlbar				myBooks[myBooks.length - 1].selectable = true;							break;			// stoppen			case "stop" :				// keine weiteren buecher				clearInterval(myInterval);							break;			// leeren			case "clear" :				// schleife ueber alle buecher				for (var i:Number = myBooks.length;  i > 0 ; i --) {					// loeschen					changeStack("remove");				}							break;		}	}		public function set ymax(num:Number ):Void	{		// maximale y-position		myYpos.max = num;	}		public function get ymax():Number	{		// zurueck geben		return (myYpos.max);	}		public function get speed():Number	{		// zurueck geben		return (_mySpeed);	}		public function get acceleration():Number	{		// zurueck geben		return (_myAcceleration);	}		public function onChangeYmax(prop, oldval, newval):Number	{		// testen, ob stapel voll		if (newval <= myYpos.min) {			// sound abspielen			_root.sound_mc.spieleSound("levelwarnung", 1);			// level beenden und spiel beenden			_global.Room.stopLevel(true);		}		// wert aendern		return (newval);	}} /* end class Stack */