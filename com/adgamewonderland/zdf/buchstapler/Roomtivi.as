/* Room** Generated from ArgoUML Model ** ActionScript 2 generator module provided by www.codealloy.com */ /*klasse:			Roomautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			zdf / tivierstellung: 		14.06.2004zuletzt bearbeitet:	13.07.2004durch			gjstatus:			in bearbeitung*/import com.adgamewonderland.zdf.buchstapler.*import com.adgamewonderland.agw.*class com.adgamewonderland.zdf.buchstapler.Roomtivi extends MovieClip {	// Attributes		private var _myWords:Array;		private var _myScores:Array;		private var _myMaxBooks:Number;		private var _myMaxWords:Array;		private var _myTime:Number;		private var mySolutions:Object;		private var myCharacters:Object;		private var myShelf:Shelftivi;		private var myStack:Stack;		private var myDisplay:Display;		private var myArrows:MovieClip;		private var myCloud:MovieClip;		private var myLevel:Number;		private var hasEnded:Boolean;		private var myScore:Number;		private var myBooks:Array;		private var myNumBooks:Object;		private var myNumWords:Object;		private var myDepth:Number;		private var myDepthchecker:Depthchecker;		private var myInterval:Number;		private var keyListener:Object;		private var book_mc:MovieClip, shelf_mc:Shelftivi, stack_mc:Stack, display_mc:Display, arrows_mc:MovieClip, cloud_mc:MovieClip;		// Operations		public  function Roomtivi()	{		// global ansprechbar		_global.Room = this;		// loesungsbegriffe und die dazu gehorigen punktzahlen		mySolutions = {};		// buchstaben (in loesungsbegriffen / fuer wahrscheinlichkeit)		myCharacters = {sol : [], rand : []};		// schleife ueber loesungsworte (aus komponentenparameter)		for (var i in _myWords) {			// in loesungsbegriffe aufnehmen			mySolutions[_myWords[i]] = _myScores[i];			// loesungsbegriff			var word:String = new String(_myWords[i]);		}				// regal		myShelf = shelf_mc;		// stapel, auf dem die buecher landen		myStack = stack_mc;		// anzeige		myDisplay = _root.display_mc;		// pfeile, die zeigen, wo das buch landet		myArrows = arrows_mc;		// wolke, die eingeblendet wird, wenn buecher verschwinden		myCloud = cloud_mc;				// level des spiels		level = 1;		// level beendet?		hasEnded = false;		// punktzahl		score = 0;				// buecher, die aktuell auf der buehne sind		myBooks = [];		// informationen zu buechern		myNumBooks = {max : _myMaxBooks, act : 0};		// informationen zu anzahl wörtern (je level, aktuell)		myNumWords = {max : _myMaxWords[level - 1], act : 0};		// deckeln		if (level >= _myMaxWords.length) myNumWords.max = _myMaxWords[_myMaxWords.length - 1];		// liefert tiefe fuer attachen (zwischen min und max)		myDepthchecker = new Depthchecker(100, 500);	}		public  function get solutions():Object	{		// zurueck geben		return (mySolutions);	}		public  function get level():Number	{		// zurueck geben		return (myLevel);	}		public  function set level(num:Number ):Void	{		// level des spiels		myLevel = num;		// anzeigen		myDisplay.showValue("level", myLevel);	}		public  function get score():Number	{		// zurueck geben		return (myScore);	}		public  function set score(num:Number ):Void	{		// punktzahl		myScore = num;		// anzeigen		myDisplay.showValue("score", myScore);	}		private function initCharacters():Void	{		// 1. buchstaben aus loesungsbegriffen als array		// 2. einige zufaellige buchstaben an das array anhaengen		// 3. array mischen		// 4. an zielarray anhaengen		// 5. sooft wiederholen, bis laenge zielarray groesser anzahl buchstaben je level				// alle buchstaben der loesungswoerter		var sol:Array = [];		// schleife ueber loesungswoerter		for (var word:String in solutions) {			// buchstaben des loesungsbegriffs als array			var chars:Array = word.split("");			// in buchstaben aufnehmen			sol = sol.concat(chars);		}		// loseungsbuchstaben merken		myCharacters["sol"] = sol;				// buchstaben in zufaelliger reihenfolge		var characters:Array = sol;// 		// zufaellige buchstaben// 		var rand:Array = getRandomCharArray(5);// 		// an loesungsbuchstaben anhaengen// 		characters = characters.concat(rand);		// shuffeln		characters = getShuffledArray(characters);		// an zufallsarray fuer ganzes level anhaengen		myCharacters["rand"] = myCharacters["rand"].concat(characters);	}		public function initRoom():Void	{		// level beendet?		hasEnded = false;		// punktzahl		score = 0;		// buecher, die aktuell auf der buehne sind		myBooks = [];		// informationen zu buechern		myNumBooks = {max : _myMaxBooks, act : 0};		// auf "p" fuer pause reagieren		keyListener = {};		// tasten beobachten		keyListener.onKeyDown = function () {			// nur auf "p" reagieren			if (Key.isDown(80) == false) return;			// pause starten			_global.Room.pauseLevel(true);		}		// verfolgen		Key.addListener(keyListener);		// button auf hauptzeitleiste aktivieren		_root.pause_btn.onRelease = function () {			// pause starten			_global.Room.pauseLevel(true);		}		// level starten		initLevel();	}		public function initLevel():Void	{		// sound abspielen		_root.sound_mc.spieleSound("levelwechsel", 1);		// pause ausblenden		showPause(false);		// levelende ausblenden		showLevelend(false);		// animation abspielen		_root.slide_mc.startSlide("out", null, null, null);		// level nicht beendet		hasEnded = false;		// buchstaben fuer wahrscheinlichkeit initialisieren		initCharacters();		// punkte anzeigen		myDisplay.showValue("score", myScore);		// level anzeigen		myDisplay.showValue("level", level);		// anzahl buecher auf 0		myNumBooks.act = 0;		// informationen zu anzahl wörtern (je level, aktuell)		myNumWords = {max : _myMaxWords[level - 1], act : 0};		// deckeln		if (level >= _myMaxWords.length) myNumWords.max = _myMaxWords[_myMaxWords.length - 1];		// anzahl wörter anzeigen		myDisplay.showValue("remaining", myNumWords.max - myNumWords.act);		// liefert tiefe fuer attachen (zwischen min und max)		myDepthchecker = new Depthchecker(100, 500);		// zufaellige buecher in regal		myShelf.showRandomBooks(_myWords);		// stapel starten		myStack.changeStack("start");	}		public function pauseLevel(bool:Boolean ):Void	{		// abbrechen, falls level beendet		if (hasEnded) return;		// anfangen / beenden		switch (bool) {			// anfangen			case true :				// nur einmal				Key.removeListener(keyListener);				// button auf hauptzeitleiste deaktivieren				_root.pause_btn.enabled = false;				// stack pausieren				myStack.changeStack("pause");				// animation abspielen				_root.slide_mc.startSlide("in", this, "showPause", true);				// sound abspielen				_root.sound_mc.spieleSound("pause", 1);								break;			// beenden			case false :				// stack pausieren beenden				myStack.changeStack("pause");				// pause ausblenden				showPause(false);				// animation abspielen				_root.slide_mc.startSlide("out", null, null, null);				// verfolgen				Key.addListener(keyListener);				// button auf hauptzeitleiste aktivieren				_root.pause_btn.enabled = true;							break;		}	}		public function showPause(bool:Boolean ):Void	{		// ein- / ausblenden		_root.pause_mc._visible = bool;	}		public function stopLevel(gameover:Boolean ):Void	{		// level beendet		hasEnded = true;		// stapel stoppen		myStack.changeStack("stop");		// nach pause level schliessen		myInterval = setInterval(this, "lockLevel", _myTime, gameover);	}		private function lockLevel(gameover:Boolean ):Void	{		// interval loeschen		clearInterval(myInterval);		// schleife ueber alle buecher		for (var i in myBooks) {			// testen, ob auch wirklich ein buch (koennte auch null sein)			if (myBooks[i] instanceof Book) {				// deaktivieren				myBooks[i].selectable = false;			}		}		// oberstes buch auf stapel deaktivieren		myStack.changeStack("lock");		// punkte fuer buecher im regal		var score:Number = myShelf.getBookCount();		// pause beim animierten anzeigen der punkte		var pause:Number = 50;		// punkte animiert anzeigen		myDisplay.animateValue("score", score, score, pause);		// punkte speichern		myScore += score;		// nachdem alle punkt gezaehlt sind level aufraeumen		myInterval = setInterval(this, "clearLevel", pause * score, gameover);	}		private function clearLevel(gameover:Boolean ):Void	{		// interval loeschen		clearInterval(myInterval);		// regal initialisieren		myShelf.initShelf();		// stapel leeren		myStack.changeStack("clear");		// schleife ueber alle buecher		for (var i in myBooks) {			// testen, ob auch wirklich ein buch (koennte auch null sein)			if (myBooks[i] instanceof Book) {				// von buehne entfernen				myBooks[i].removeMovieClip();			}		}		// je nachdem, ob spiel vorbei oder nicht		switch (gameover) {			// spiel vorbei, zur highscoreliste			case true :				// punkte uebergeben				_root.highscore_mc.showGameover("buchstapler", myScore);// 				_root.sender.sendScore(myScore);								break;			// neues level			case false :				// level hochzaehlen				level ++;				// animation abspielen				_root.slide_mc.startSlide("in", this, "showLevelend", true);								break;		}	}		public function showLevelend(bool:Boolean ):Void	{		// ein- / ausblenden		_root.levelend_mc._visible = bool;		// informationen zu anzahl wörtern im naechsten level		var max:Number = _myMaxWords[level - 1];		// deckeln		if (level >= _myMaxWords.length) max = _myMaxWords[_myMaxWords.length - 1];		// anzahl der wörter, die gelegt werden muessen		_root.levelend_mc.showNumWords(level, max);	}		public function isShelfFree():Boolean	{		// ist noch platz im regal		return (myShelf.getFreeBoards() > 0);	}		public function addBook(pos:Point, parent:MovieClip, character:String ):MovieClip	{		// tiefe fuer attachen		var depth:Number = myDepthchecker.getFreeDepth();		// buchstabe		if (character.length != 1) character = getRandomCharacter();		// constructor (position, stack als parent, buchstabe)		var constructor:Object = {_x : pos.x, _y : pos.y, myParent : parent, myCharacter : character};		// neues buch auf buehne		var mc:MovieClip = this.attachMovie("book", "book" + depth + "_mc", depth, constructor);		// in array schreiben		myBooks[depth] = mc;		// zurueck geben		return (mc);	}		private function getRandomCharacter():String	{		// buchstaben aus zufallsarray entsprechend aktuellem buch		var rand:String = myCharacters["rand"][myNumBooks.act];		// zurueck geben		return (rand);	}		public function countBook():Void	{		// buecher zaehlen		myNumBooks.act ++;		// testen, ob keine zufallsbuchstaben mehr vorhanden		if (myNumBooks.act % myCharacters["rand"].length == 0) {			// neue zufallsbuchstaben			initCharacters();		}	}		public function onDragBook(book:Book ):Roomtivi	{		// ganz nach vorne		book.swapDepths(1000);		// position, an der das buch landen wuerde		var droppos:Point = myShelf.getDropPos(book.position);		// pfeile ganz nach vorne		myArrows.swapDepths(1001);		// pfeile positionieren		myArrows._x = droppos.x;		myArrows._y = droppos.y;			// zurueck geben		return this;	}		public function onDropBook(book:Book ):Board	{		// wieder nach hinten		book.swapDepths(book.depth);		// pfeile neben buehne		myArrows._x = -20;		// position des buchs		var pos:Point = book.position;		// regalbrett an dieser position		var board:Board = myShelf.getBoardByPos(pos);		// einsortieren		board.insertBook(book);		// sound abspielen		_root.sound_mc.spieleSound("bucheinsortieren", 1);				// buch deaktivieren, wenn level beendet		if (hasEnded) book.selectable = false;				// oberstes buch auf stapel deaktivieren, wenn regal voll		if (isShelfFree() == false) myStack.changeStack("lock");			// zurueck geben		return board;	}		public function onRemoveBook(book:Book ):Void	{		// depth frei geben		myDepthchecker.setDepthFree(book.depth);		// aus array loeschen		myBooks[book.depth] = null;				// oberstes buch auf stapel aktivieren, da regal nicht mehr voll sein kann		myStack.changeStack("unlock");	}		public function checkSolution(word:String ):Object	{		// loesungsobject (anfang im word, ende im word, punktzahl)		var solution:Object = {first : -1, last : -1, score : 0};		// schleife ueber loesungswoerter		for (var sol:String in solutions) {			// testen, ob loesungswort in word, index merken			if ((solution.first = word.indexOf(sol)) != -1) {				// ende im word				solution.last = solution.first + sol.length;				// punktzahl				solution.score = solutions[sol];				// abbrechen				break;			}		}		// zurueck geben		return (solution);	}		public function showCloud(board:Board, solution:Object ):Void	{		// sound abspielen		_root.sound_mc.spieleSound("buchkombi", 1);		// index des buches in der mitte der zu entfernenden buecher		var index:Number = solution.first + (solution.last - solution.first) / 2;		// position an diesem index		var pos:Point = board.getPosByIndex(index);		// wolke ganz nach vorne		myCloud.swapDepths(1002);		// wolke positionieren		myCloud._x = pos.x;		myCloud._y = pos.y;		// punktzahl uebergeben		myCloud.myScore = solution.score;		// abspielen verfolgen		onEnterFrame = function () {			// testen, ob wolke fertig			if (myCloud._currentframe == myCloud._totalframes) {				// buecher loeschen				board.clearSolution(solution);				// wolke neben buehne				myCloud._x = -60;				// wort zaehlen				countWord();				// verfolgen beenden				delete (onEnterFrame);			}		}		// wolke abspielen		myCloud.play();	}		public function countScore(num:Number ):Void	{		// addieren		myScore += num;		// anzeigen		myDisplay.showValue("score", myScore);	}		private function countWord():Void	{		// wörter zaehlen		myNumWords.act ++;		// anzahl wörter anzeigen		myDisplay.showValue("remaining", myNumWords.max - myNumWords.act);		// testen, ob level durch		if (myNumWords.act == myNumWords.max && hasEnded == false) {			// level stoppen, aber spiel noch nicht vorbei			stopLevel(false);		}	}		// methode "getRandomNumArray" gibt array mit zufallszahlen gemaess uebergebenen parametern zurueck	public function getRandomNumArray(length:Number, min:Number, max:Number, freq:Number):Array	{		// haeufigkeiten der erlaubten zahlen setzen		var nums:Array = new Array(max - min + 1);		// schleife ueber gesamten erlaubten bereich		var i:Number = 0;		while (i < (max - min + 1)) {			// erlaubte zahl setzen			nums[i] = freq;			// und weiter			i ++;		}				// array fuer die zufallszahlen		var tmp:Array = new Array(length);		// schleife ueber alle elemente		for (var i = 0; i < length; i ++) {			// keine passende zahl gefunden			var found:Boolean = false;			// zufallszahl erzeugen			do {				// zufallszahl >=min && <=max				var rand:Number = Math.floor(min + Math.random() * (max - min + 1));				// diese zahl darf genommen werden, wenn noch nicht alle instanzen verbraucht				if (--nums[rand - min] >= 0) found = true;			} while (found == false);			// zufallszahl speichern			tmp[i] = rand;		}				// zurueck geben		return (tmp);	}		private function getRandomCharArray(length:Number ):Array	{		// zufallsarray mit buchstaben		var chars:Array = [];		// buchstaben des alphabets		var alpha:String = "abcdefghijklmnopqrstuvwxyz";		// zufallsarray mit zahlen, um einige der buchstaben auszuwaehlen		var rand:Array = getRandomNumArray(length, 0, alpha.length - 1, 1);		// zufaellige buchstaben einfuegen		for (var i:Number = 0; i < length; i ++) {			// buchstabe einfuegen			chars.push(alpha.substr(rand[i], 1));		}		// zurueck geben		return (chars);	}		private function getShuffledArray(arr:Array ):Array	{		// temporaeres array		var tmp:Array = [];		// nach zufallsfunktion sortieren		tmp = arr.sort(function() { return Math.floor(Math.random() * 3) - 1;});		// zurueck geben		return (tmp);	}} /* end class Room */