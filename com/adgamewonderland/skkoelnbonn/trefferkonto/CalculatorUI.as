/*klasse:			CalculatorUIautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			sk koelnbonnerstellung: 		06.01.2005zuletzt bearbeitet:	18.05.2005durch			gjstatus:			in bearbeitung*/import com.adgamewonderland.skkoelnbonn.trefferkonto.*class com.adgamewonderland.skkoelnbonn.trefferkonto.CalculatorUI extends MovieClip {	// Attributes		private static var BONUS_SOCCER:Number = 0.01 / 1;		private static var BONUS_BASKET:Number = 0.01 / 75;		private static var BONUS_SPECIAL:Number = 0.25;		private static var DURATION1:Number = 11;		private static var DURATION2:Number = 6;		private static var INTEREST:Number = 1.50;		private var myResult:Result;		private var myNumCalcs:Number = 0;		private var result_mc:ResultUI;	 	private var input_mc:InputUI;		// Operations		public function CalculatorUI()	{		// ergebnis der berechnung (duration, interest, actual, bonus1, bonus2, bonustotal, revenue)		myResult = new Result(DURATION1 + DURATION2, INTEREST, INTEREST, 0, 0, 0, 0);	}		public function calculateResult(inp:Input ):Void	{			// am anfang keine berechnung//		if (++myNumCalcs < 10) return;		// neues ergebnis berechnen		// anzahl nachkommastellen beim runden		var digits:Number = 1e2;				// bonus [%] saison 1		var bonus1:Number = 0;		// tore		bonus1 += inp.getScore(1) * BONUS_SOCCER;		// koerbe (gerundet)		bonus1 += getRoundedValue(inp.getScore(3) * BONUS_BASKET, digits);		// aufstieg		bonus1 += inp.getSpecial(1) * BONUS_SPECIAL;		// finale		bonus1 += inp.getSpecial(3) * BONUS_SPECIAL;		// halbieren, da saison schon halb vorbei		bonus1 /= 2;		// runden		bonus1 = getRoundedValue(bonus1, digits); // Math.round(bonus1 * digits) / digits;				// speichern		myResult.bonus1 = bonus1;				// bonus [%] saison 2		var bonus2:Number = 0;		// tore		bonus2 += inp.getScore(2) * BONUS_SOCCER;		// koerbe (gerundet)		bonus2 += getRoundedValue(inp.getScore(4) * BONUS_BASKET, digits);		// aufstieg / klassenerhalt		bonus2 += inp.getSpecial(2) * BONUS_SPECIAL;		// finale		bonus2 += inp.getSpecial(4) * BONUS_SPECIAL;		// speichern		myResult.bonus2 = bonus2;				// bonus gesamt		myResult.bonustotal = getRoundedValue(bonus1 + bonus2, digits);				// ertrag [�] saison 1		var revenue1:Number = 0;		// angelegten betrag ueber laufzeit 1 verzinsen		revenue1 = inp.investment * (1 + DURATION1 / 12 * INTEREST / 100);		// bonus1 auf unverzinsten angelegten betrag gewaehren		revenue1 += inp.investment * bonus1 / 100;				// ertrag [�] saison 2		var revenue2:Number = 0;		// verzinsten und bonifizierten angelegten betrag ueber laufzeit 2 verzinsen		revenue2 = revenue1 * (1 + DURATION2 / 12 * INTEREST / 100);		// bonus2 auf unverzinsten angelegten betrag gewaehren		revenue2 += inp.investment * bonus2 / 100;				// ertrag gesamt		myResult.revenue = getRoundedValue(revenue2, digits);				// effektivzins (gerundet)		var actual:Number = getRoundedValue((Math.pow(revenue2 / inp.investment, 12 / (DURATION1 + DURATION2)) - 1) * 100, digits);		// speichern		myResult.actual = actual;				// ergebnis anzeigen		result_mc.showResult(myResult);	}		private function getRoundedValue(val:Number, digits:Number ):Number	{		// 18.05.2005		// fehler bei der berechnung		// flash hat z.b. 0.575 * 100 als 57.49999999993 berechnet und rundet dann logischerweise ab (=> 57.0)		// workaround: mit hilfe von string testen, ob genau .5, dann aufrunden)				// gerundeter wert		var round:Number;		// verschiebung des kommas um anzahl nachkommastellen		var num:Number = (val * digits);		// umwandlung in string um nachkommawert zu ermitteln		var str:String = String(num);		// nachkommawert		var fractional:String = str.split(".")[1];				// sonderbehandlung fuer .5		if (fractional == "5") {			// aufrunden			round = Math.ceil(num) / digits;		} else {			// normal runden			round = Math.round(num) / digits;		}		// zurueck geben		return round;		//		// runden und zurueck geben//		return (Math.round(val * digits) / digits);	}} /* end class CalculatorUI */