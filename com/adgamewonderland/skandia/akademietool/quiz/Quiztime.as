/*klasse:			Quiztimeautor: 			gerd jungbluth, adgame-wonderlandemail:			gerd.jungbluth@adgame-wonderland.dekunde:			skandiaerstellung: 		06.12.2004zuletzt bearbeitet:	02.02.2005durch			gjstatus:			final*/import com.adgamewonderland.skandia.akademietool.interfaces.*;import com.adgamewonderland.skandia.akademietool.quiz.*;class com.adgamewonderland.skandia.akademietool.quiz.Quiztime {	// Attributes		private var myDate:Date;		private var myTimeStart:Number;		private var myTimeAct:Number;		private var myTimeEnd:Number;		private var myTimePause:Number;		private var myStatus:Boolean;		private var myConsumers:Array;		private var myUIs:Array;		private var myInterval:Number;		// Operations		// konstruktor	public function Quiztime(dnum:Number )	{		// aktuelles datum		myDate = null;		// startzeit, aktuelle zeit, endzeit		myTimeStart = myTimeAct = myTimeEnd = 0; // myDate.getTime();		// pausenzeit		myTimePause = 0;		// status (an / aus)		myStatus = false;		// registrierte consumer		myConsumers = [];		// registrierte user interfaces		myUIs = [];	}		public function get date():Date	{		// aktuelles datum		return(myDate);	}		public function set status(bool:Boolean ):Void	{		// status (an / aus)		myStatus = bool;	}		public function get status():Boolean	{		// status (an / aus)		return(myStatus);	}		public function getPercent():Number	{		// prozent vergangene zeit		return ((myTimeAct - myTimePause - myTimeStart) / (myTimeEnd - myTimePause - myTimeStart) * 100);	}		public function getSeconds():Object	{		// sekunden (gesamt, vergangen, verbleibend)		var seconds:Object = {total : 0, gone : 0, left : 0};		// gesamt		seconds.total = Math.round((myTimeEnd - myTimePause - myTimeStart) / 1000);		// vergangen		seconds.gone =  Math.round((myTimeAct - myTimePause - myTimeStart) / 1000);		// verbleibend		seconds.left =  Math.round((myTimeEnd - myTimeAct) / 1000);		// zurueck geben		return (seconds);	}		public function addConsumer(con:ITimeConsumer ):Void	{		// neuer consumer		myConsumers.push(con);	}		public function addUI(ui:ITimeUI ):Void	{		// neues user interface		myUIs.push(ui);	}		public function startTime(duration:Number ):Void	{		// aktuelles datum		myDate = new Date();		// startzeit		myTimeStart = getTimer();		// aktuelle zeit		myTimeAct = myTimeStart;		// endzeit		myTimeEnd = myTimeStart + duration * 1000;		// pausenzeit		myTimePause = 0;		// regelmaessig updaten		myInterval = setInterval(this, "updateTime", 500);	}		public function stopTime():Void	{		// zaehlen beenden		clearInterval(myInterval);	}		private function updateTime():Void	{		// zeit seit start swf		var now:Number = getTimer();		// datum updaten (plus ms seit letztem update)		myDate.setTime(myDate.getTime() + (now - myTimeAct));				// je nach status		switch (status) {			// zeit laueft nicht			case false :				// pausenzeit verlaengern				myTimePause += (now - myTimeAct);				// zeit bis zum ende verlaengern				myTimeEnd += (now - myTimeAct);								break;			// zeit laueft			case true :							break;		}		// aktuelle zeit		myTimeAct = now;		// user interfaces updaten		for (var i:String in myUIs) myUIs[i].showTime(this);		// testen, ob zeit abgelaufen		if (myTimeAct >= myTimeEnd) {			// zaehlen beenden			stopTime();			// consumer benachrichtigen			for (var j:String in myConsumers) myConsumers[j].onTimeEnded();		}	}	} /* end class Quiztime */