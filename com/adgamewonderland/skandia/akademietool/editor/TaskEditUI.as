/*klasse:			TaskEditUIautor: 			gerd jungbluth, adgamewonderlandemail:			gerd.jungbluth@adgamewonderland.dekunde:			skandiaerstellung: 		08.02.2005zuletzt bearbeitet:	23.09.2005durch			gjstatus:			final*/import mx.rpc.ResultEvent;import mx.rpc.FaultEvent;import mx.remoting.RecordSet;import mx.utils.Iterator;import com.adgamewonderland.skandia.akademietool.editor.*;import com.adgamewonderland.skandia.akademietool.quiz.*;class com.adgamewonderland.skandia.akademietool.editor.TaskEditUI extends MovieClip {		private static var DROPDOWN_YDIFF:Number = 20;		private var myEditorUI:EditorUI;		private var myTask:EditorTask;		private var myTextfields:Array;		private var myCheckboxes:Array;		private var myDropdowns:Array;		private var headline_txt:TextField;		private var question_txt:TextField;		private var answer1_txt:TextField;		private var answer2_txt:TextField;		private var answer3_txt:TextField;		private var answer4_txt:TextField;		private var explanation_txt:TextField;		private var checkbox1_mc:CheckboxUI;		private var checkbox2_mc:CheckboxUI;		private var checkbox3_mc:CheckboxUI;		private var checkbox4_mc:CheckboxUI;		private var difficulty_mc:DropdownUI;		private var topic_mc:DropdownUI;		private var active_mc:DropdownUI;		private var supplier_mc:DropdownUI;		private var save_btn:Button;		private var reset_btn:Button;		private var delete_btn:Button;		private var list_btn:Button;		private var close_btn:Button;		public function TaskEditUI()	{		// aufgabe als object (tid, question, difficulty, topic, active, supplier, explanation)		myTask = new EditorTask(null);		// alle textfelder		myTextfields = [];		// alle checkboxen		myCheckboxes = [checkbox1_mc, checkbox2_mc, checkbox3_mc, checkbox4_mc];		// alle dropdowns		myDropdowns = [difficulty_mc, topic_mc, active_mc, supplier_mc];		// editor		myEditorUI = EditorUI(_parent);		// speichern button		save_btn.onRelease = function() {			this._parent.saveTask();		};		// reset button		reset_btn.onRelease = function() {			this._parent.init(null);		};		// loeschen button		delete_btn.onRelease = function() {			this._parent.deleteTask();		};		// liste button		list_btn.onRelease = function() {			this._parent.myEditorUI.showTaskList();		};		// abbrechen button		close_btn.onRelease = function() {			this._parent.myEditorUI.showWelcome();		};		// headline linksbuendig		headline_txt.autoSize = "left";		// tabindizes		question_txt.tabIndex = 1;		answer1_txt.tabIndex = 2;		answer2_txt.tabIndex = 3;		answer3_txt.tabIndex = 4;		answer4_txt.tabIndex = 5;		explanation_txt.tabIndex = 6;				// felhlermeldung ausblenden		myEditorUI.showMessage(false, 0);	}		public function init(tid:Number ):Void	{		// aufgabe als object (tid, question, difficulty, topic, active, supplier, explanation)		myTask = new EditorTask(null);		// alle textfelder		myTextfields = [];		// entweder aufgabe oder leere felder		switch (tid != null) {			// aufgabe			case true:				// headline				headline_txt.text = "Frage bearbeiten";				// ohne reset				reset_btn._visible = false;				// aufgabe laden				loadTask(tid);								break;			// leere felder			case false:				// headline				headline_txt.text = "Neue Frage einpflegen";				// ohne liste				list_btn._visible = false;				// dropdowns inititialisieren				initDropdowns();				// frage				initTextfield(question_txt, "Geben Sie hier Ihren Fragentext ein.", 512);				// antworten				initAnswers();				// erlaeuterung				initTextfield(explanation_txt, "Falls gewünscht, geben Sie hier Ihren Erläuterungstext ein.", 1024);							break;		}		}		private function loadTask(tid:Number ):Void	{		// aufgabe laden lassen		EditorConnector.loadTask(tid, this, "onTaskLoaded");		// loader anzeigen		myEditorUI.showLoader(true, "Frage wird geladen");	}		public function onTaskLoaded(re:ResultEvent ):Void	{		// erster datensatz ist aufgabe		var task:Object = re.result.getItemAt(0);		// inhalte der spalten in aufgaben-objekt speichern		for (var column:String in task) {			// eigenschaft in kleinbuchstaben			myTask[column.toLowerCase()] = task[column];		}		// bei erklaerung null abfangen		if (myTask.explanation == null) myTask.explanation = "";		// antworten laden		loadAnswers();	}		private function loadAnswers():Void	{		// antworten laden lassen		EditorConnector.loadAnswers(myTask.tid, this, "onAnswersLoaded");	}		public function onAnswersLoaded(re:ResultEvent ):Void	{		// loader ausblenden		myEditorUI.showLoader(false);		// datensaetze sind antworten		var answers:RecordSet = RecordSet(re.result);		// antworten		myTask.answers = [];		// antworten speichern		for (var i:Number = 0; i < answers.length; i++) {			// aktuelle antwort			var answer:Object = answers.getItemAt(i);			// aktuelle antwort und korrektheit			myTask.answers.push(new EditorAnswer(answer.ANSWER, answer.CORRECT));		}		// dropdowns inititialisieren		initDropdowns();		// aufgabe anzeigen		showTask();	}		private function saveTask():Void	{		// fehlerhafte objekte		var errors:Array = [];		// textfelder checken		for (var i:String in myTextfields) {			// aktuelles feld			var field:TextField = myTextfields[i];			// erklaerung darf default / leer sein			if (field == explanation_txt) {				// wenn default, leeren				if (field.text == field.defaultText) field.text = "";			} else {				// 1. default-wert				if (field.text == field.defaultText) errors.push(field);				// 2. leer				if (field.text == "") errors.push(field);			}		}		// anzahl angekreuzter checkboxen		var checked:Number = 0;		// checkboxen checken		for (var j:String in myCheckboxes) {			// aktuelle checkbox			var checkbox:CheckboxUI = myCheckboxes[j];			// 1. zaehlen, wenn angekreuzt			if (checkbox.status == true) checked++;		}		// keine angekreuzt		if (checked == 0) errors.push(checked);		// dropdowns checken		for (var k:String in myDropdowns) {			// aktuelles dropdown			var dropdown:DropdownUI = myDropdowns[k];			// 1. nicht bearbeitet			if (dropdown.current == 0) errors.push(dropdown);		}		// abbrechen wenn fehler gefunden		if (errors.length > 0) {			// meldung anzeigen			myEditorUI.showMessage(true, 1);			// abbrechen			return;		}				// frage		myTask.question = question_txt.text;		// antworten		myTask.answers = [];		// schleife ueber alle antworten		for (var m:Number = 1; m <= myCheckboxes.length; m++) {			// aktuelle antwort und korrektheit			myTask.answers.push(new EditorAnswer(this["answer" + m + "_txt"].text, (this["checkbox" + m + "_mc"].status == true ? 1 : 0)));		}		// erklaerung		myTask.explanation = explanation_txt.text;		// schwierigkeitsgrad		myTask.difficulty = difficulty_mc.current;		// themengebiet		myTask.topic = topic_mc.current;		// aktivitaet		myTask.active = active_mc.current - 1;		// autor		myTask.supplier = supplier_mc.current;				// aufgabe speichern lassen		EditorConnector.sendTask(myEditorUI.user.userid, myTask, this, "onTaskSaved");		// loader anzeigen		myEditorUI.showLoader(true, "Frage wird gespeichert");	}		public function onTaskSaved(re:ResultEvent ):Void	{		// loader ausblenden		myEditorUI.showLoader(false);		// meldung anzeigen, je nachdem ob neue frage oder nicht		if (myTask.tid == null) {			myEditorUI.showMessage(true, 2);		} else {			myEditorUI.showMessage(true, 3);		}		// task id der gespeicherten aufgabe		myTask.tid = Number(re.result);	}		private function deleteTask():Void	{		// aktuelle tid		var tid:Number = myTask.tid;		// abbrechen, wenn keine aufgabe		if (tid == null) return;		// aufgabe loeschen lassen		EditorConnector.deleteTask(tid, this, "onTaskDeleted");		// loader anzeigen		myEditorUI.showLoader(true, "Frage wird gelöscht");	}		public function onTaskDeleted(re:ResultEvent ):Void	{		// loader ausblenden		myEditorUI.showLoader(false);		// resetten		init(null);	}		public function onConnectorFault(fe:FaultEvent ):Void	{   		trace("There was a problem: " + fe.fault.faultstring);	   	trace("The faultcode is: " + fe.fault.faultcode);	 	trace("The detail: " + fe.fault.detail);	   	trace("The error class name is: " + fe.fault.type);	}		private function initTextfield(field:TextField, deftxt:String, maxlength:Number ):Void	{		// default text		field.text = field.defaultText = deftxt; 		// beim betreten ggf. leeren 		field.onSetFocus = function () { 			// leeren, wenn default 			if (this.text == this.defaultText) this.text = "";	 		}; 		// beim verlassen ggf. default nehmen		field.onKillFocus = function() {			// wenn leer, default			if (this.text == "") this.text = this.defaultText;		};		// maximale anzahl zeichen		field.maxChars = maxlength;		// speichern		myTextfields.push(field);	}		private function initDropdowns():Void	{		// inhalt fuer dropdowns		var content:DropdownContent = myEditorUI.dropdowncontent;		// schwierigkeitsgrad		difficulty_mc.initDropdownUI("Schwierigkeitsgrad", content.difficulties, myEditorUI.getValuesArray(content.difficulties), this, null, DROPDOWN_YDIFF);		// themengebiet		topic_mc.initDropdownUI("Themengebiet", content.topics, myEditorUI.getValuesArray(content.topics), this, null, DROPDOWN_YDIFF);		// autor		supplier_mc.initDropdownUI("Autor", content.suppliers, myEditorUI.getValuesArray(content.suppliers), this, null, DROPDOWN_YDIFF);		// aktivitaet		active_mc.initDropdownUI("Status", ["nicht aktiv", "aktiv"], myEditorUI.getValuesArray(content.activities), this, null, DROPDOWN_YDIFF);	}		private function initAnswers():Void	{		// counter		var counter:Number = 0;		// aktuelle antwort		var answer:TextField;		// alle antworten resetten		while ((answer = this["answer" + (++counter) + "_txt"]) instanceof TextField) {			// default text			initTextfield(answer, "hier Antwort " + counter + " eingeben", 256);			// checkbox abschalten			this["checkbox" + counter + "_mc"].status = false;		}	}		private function showTask():Void	{		// frage		question_txt.text = myTask.question;		// erklaerung		explanation_txt.text = myTask.explanation;		// antworten		for (var i:Number = 0; i < myTask.answers.length; i++) {			// aktuelle antwort			var answer:EditorAnswer = myTask.answers[i];			// anzeigen			this["answer" + (i + 1) + "_txt"].text = answer.text;			// checkbox aendern			this["checkbox" + (i + 1) + "_mc"].status = (answer.correct == 1 ? true : false);		}		// schwierigkeitsgrad (-1, da dropdown 0-basiert und datenbank 1-basiert)		difficulty_mc.onSelectItem(myTask.difficulty - 1);		// themengebiet (-1, da dropdown 0-basiert und datenbank 1-basiert)		topic_mc.onSelectItem(myTask.topic - 1);		// autor (-1, da dropdown 0-basiert und datenbank 1-basiert)		supplier_mc.onSelectItem(myTask.supplier - 1);		// aktivitaet		active_mc.onSelectItem(myTask.active);	}	} /* end class TaskEditUI */